
struct Vertex {
    pos: inline Vec3f = {};
    color: inline Colorf = {};
}

struct DrawCommands {
    vertices: [](inline Vertex) = {};
    indices: []u32 = {};
}

struct Globals {
    screenSize: inline Vec2f;
}

max<T>(a: T, b: T): T => {
    if a >= b {
        return a;
    }
    return b;
}

min<T>(a: T, b: T): T => {
    if a <= b {
        return a;
    }
    return b;
}

struct PrimitiveInstance {
    pos: inline Vec2f;            // center position in pixels
    size: inline Vec2f;           // width/height
    radius: f32;           // corner radius for rounded rect
    borderThickness: f32;  // 0 = no border
    fillColor: inline Colorf;
    borderColor: inline Colorf;
    type: u32;             // 0 = rect, 1 = circle, etc.
};

struct QuadVertex {
    pos: inline Vec2f;  // [-0.5, -0.5] .. [0.5, 0.5]
};

opaque struct Renderer {
    windowSize: Vec2i;
    queue: mut wgpu.Queue;
    device: mut wgpu.Device;
    surface: mut wgpu.Surface;
    pipeline: mut wgpu.RenderPipeline;
    globalsBuffer: mut wgpu.Buffer;
    globalsBindGroup: mut wgpu.BindGroup;

    vertexBuffer?: mut wgpu.Buffer;
    currentVertexBufferSize?: int;
    indexBuffer?: mut wgpu.Buffer;
    currentIndexBufferSize?: int;

    commands: mut DrawCommands = {};

    constructor(size: Vec2i, device: mut wgpu.Device, surface: mut wgpu.Surface, surfaceFormats: []wgpu.TextureFormat) {
        let queue = device.getQueue();
        if !queue { 
            sys.panic("Failed to get queue");
        }

        let vertexLayout = wgpu.VertexBufferLayout {
            arrayStride: sizeof(type<inline QuadVertex>),
            stepMode: wgpu.VertexStepMode.Vertex,
            attributes: {
                {
                    shaderLocation: 0,
                    offset: 0,
                    format: wgpu.VertexFormat.Float32x2,
                },
                // {
                //     shaderLocation: 1,
                //     offset: sizeof(type<inline Vec3f>),
                //     format: wgpu.VertexFormat.Float32x4,
                // },
            },
        };

        let instanceLayout = wgpu.VertexBufferLayout {
            arrayStride: sizeof(type<inline PrimitiveInstance>),
            stepMode: wgpu.VertexStepMode.Instance, // key! this is per-instance
            attributes: {
                { shaderLocation: 1, offset: 0, format: wgpu.VertexFormat.Float32x2 }, // pos
                { shaderLocation: 2, offset: 8, format: wgpu.VertexFormat.Float32x2 }, // size
                { shaderLocation: 3, offset: 16, format: wgpu.VertexFormat.Float32 },   // radius
                { shaderLocation: 4, offset: 20, format: wgpu.VertexFormat.Float32 },   // borderThickness
                { shaderLocation: 5, offset: 24, format: wgpu.VertexFormat.Float32x4 }, // fillColor
                { shaderLocation: 6, offset: 40, format: wgpu.VertexFormat.Float32x4 }, // borderColor
                { shaderLocation: 7, offset: 56, format: wgpu.VertexFormat.Uint32 },    // type
            },
        };

        let globalsLayout = device.createBindGroupLayout({
            entries: {
                {
                    binding: 0,
                    visibility: wgpu.ShaderStage.Vertex,
                    buffer: { type: wgpu.BufferBindingType.Uniform },
                },
            },
        });

        let globalsBuffer = device.createBuffer({
            usage: wgpu.BufferUsage.Uniform | wgpu.BufferUsage.CopyDst,
            size: sizeof(type<inline Globals>),
        });

        let globalsBindGroup = device.createBindGroup({
            layout: globalsLayout,
            entries: {
                {
                    binding: 0,
                    buffer: globalsBuffer,
                    offset: 0,
                    size: sizeof(type<inline Globals>),
                },
            },
        });

        let pipelineLayout = device.createPipelineLayout({
            bindGroupLayouts: { globalsLayout },
        });

        let code = fs.readFile("test/shaders.wgsl");
        assert(code);
        let shader = g_device.createShaderModule({
            code: code,
        });


        let pipeline = device.createRenderPipeline({
            layout: pipelineLayout,
            vertex: {
                module: shader,
                entryPoint: "vs_main",
                buffers: { vertexLayout, instanceLayout },
            },
            fragment: {
                module: shader,
                entryPoint: "fs_main",
                targets: {
                    { 
                        format: surfaceFormats[0],
                        blend: {
                            color: {
                                srcFactor: wgpu.BlendFactor.SrcAlpha,
                                dstFactor: wgpu.BlendFactor.OneMinusSrcAlpha,
                                operation: wgpu.BlendOperation.Add,
                            },
                            alpha: {
                                srcFactor: wgpu.BlendFactor.One,
                                dstFactor: wgpu.BlendFactor.OneMinusSrcAlpha,
                                operation: wgpu.BlendOperation.Add,
                            },
                        },
                    },
                },
            },
            primitive: {
                topology: wgpu.PrimitiveTopology.TriangleList,
            },
        });

        return Renderer {
            windowSize: size,
            device: device,
            queue: queue,
            surface: surface,
            pipeline: pipeline,
            globalsBuffer: globalsBuffer,
            globalsBindGroup: globalsBindGroup,
        };
    }

    struct TriangleVertex {
        pos: Vec2;
        color: Color;
    };

    drawTriangle(a: TriangleVertex, b: TriangleVertex, c: TriangleVertex) {
        let baseIndex = this.commands.vertices.length;

        this.commands.vertices.push({
            pos: Vec3f(a.pos.x as f32, a.pos.y as f32, 0.0 as f32),
            color: Colorf(a.color.r as f32, a.color.g as f32, a.color.b as f32, a.color.a as f32),
        });
        this.commands.vertices.push({
            pos: Vec3f(b.pos.x as f32, b.pos.y as f32, 0.0 as f32),
            color: Colorf(b.color.r as f32, b.color.g as f32, b.color.b as f32, b.color.a as f32),
        });
        this.commands.vertices.push({
            pos: Vec3f(c.pos.x as f32, c.pos.y as f32, 0.0 as f32),
            color: Colorf(c.color.r as f32, c.color.g as f32, c.color.b as f32, c.color.a as f32),
        });

        let indexA = baseIndex;
        let indexB = baseIndex + 1;
        let indexC = baseIndex + 2;

        assert(indexA >= u32.min && indexA <= u32.max);
        assert(indexB >= u32.min && indexB <= u32.max);
        assert(indexC >= u32.min && indexC <= u32.max);

        this.commands.indices.push(indexA);
        this.commands.indices.push(indexB);
        this.commands.indices.push(indexC);
    }

    drawRect(pos: Vec2, size: Vec2, color: Color) {
        this.drawTriangle(
            { pos: Vec2(pos.x, pos.y), color: color },
            { pos: Vec2(pos.x + size.x, pos.y), color: color },
            { pos: Vec2(pos.x + size.x, pos.y + size.y), color: color },
        );
        this.drawTriangle(
            { pos: Vec2(pos.x + size.x, pos.y + size.y), color: color },
            { pos: Vec2(pos.x, pos.y + size.y), color: color },
            { pos: Vec2(pos.x, pos.y), color: color },
        );
    }

    drawQuarterCircle(
        center: Vec2,
        radius: real,
        startAngle: real,
        endAngle: real,
        color: Color,
        segments: int,
    ) {
        let step = (endAngle - startAngle) / (segments as real);
        let prev = Vec2(
            center.x + math.cos(startAngle) * radius,
            center.y + math.sin(startAngle) * radius,
        );

        for (let i = 0; i <= segments; i++) {
            let a = startAngle + step * (i as real);
            let p = Vec2(
                center.x + math.cos(a) * radius,
                center.y + math.sin(a) * radius,
            );

            this.drawTriangle(
                { pos: center, color: color },
                { pos: prev,   color: color },
                { pos: p,      color: color },
            );

            prev = p;
        }
    }

    drawRoundedRect(
        pos: Vec2,
        size: Vec2,
        radius: real,
        color: Color,
    ) {
        let r = min<real>(radius, min<real>(size.x, size.y) * 0.5);

        // center rect
        this.drawRect(
            Vec2(pos.x + r, pos.y + r),
            Vec2(size.x - (2 as real)*r, size.y - (2 as real)*r),
            color
        );

        // side rects
        this.drawRect(Vec2(pos.x + r, pos.y),           Vec2(size.x - 2.0*r, r), color); // top
        this.drawRect(Vec2(pos.x + r, pos.y + size.y-r),Vec2(size.x - 2.0*r, r), color); // bottom
        this.drawRect(Vec2(pos.x, pos.y + r),           Vec2(r, size.y - 2.0*r), color); // left
        this.drawRect(Vec2(pos.x + size.x-r, pos.y + r),Vec2(r, size.y - 2.0*r), color); // right

        let segs = 8; // good default

        // corners (clockwise)
        this.drawQuarterCircle(
            Vec2(pos.x + r, pos.y + r),
            r, math.pi(), math.pi()*1.5, color, segs
        );

        this.drawQuarterCircle(
            Vec2(pos.x + size.x - r, pos.y + r),
            r, math.pi()*1.5, math.pi()*2.0, color, segs
        );

        this.drawQuarterCircle(
            Vec2(pos.x + size.x - r, pos.y + size.y - r),
            r, 0.0, math.pi()*0.5, color, segs
        );

        this.drawQuarterCircle(
            Vec2(pos.x + r, pos.y + size.y - r),
            r, math.pi()*0.5, math.pi(), color, segs
        );
    }

    beginFrame() {
        this.commands = {};
    }

    endFrame() {

        this.commands.indices = {
            0, 1, 2, 0, 2, 3
        }

        let needVertexBufferSize = sizeof(type<inline Vertex>) * this.commands.vertices.length;
        if !this.vertexBuffer || (!this.currentVertexBufferSize || this.currentVertexBufferSize != needVertexBufferSize) {
            this.vertexBuffer = this.device.createBuffer({
                usage: wgpu.BufferUsage.Vertex | wgpu.BufferUsage.CopyDst,
                size: needVertexBufferSize,
            });
            assert(this.vertexBuffer);
            this.currentVertexBufferSize = needVertexBufferSize;
            this.queue.writeBuffer<inline Vertex>(this.vertexBuffer, this.commands.vertices);
        }
        assert(this.vertexBuffer);

        let needIndexBufferSize = sizeof(u32) * this.commands.indices.length;
        if !this.indexBuffer || (!this.currentIndexBufferSize || this.currentIndexBufferSize != needIndexBufferSize) {
            this.indexBuffer = this.device.createBuffer({
                usage: wgpu.BufferUsage.Index | wgpu.BufferUsage.CopyDst,
                size: needIndexBufferSize,
            });
            this.currentIndexBufferSize = needIndexBufferSize;
            assert(this.indexBuffer);
            this.queue.writeBuffer<u32>(this.indexBuffer, this.commands.indices);
        }
        assert(this.indexBuffer);

        let surfaceTexture = this.surface.getCurrentTexture();
        if !surfaceTexture.texture { 
            fmt.println("Failed to get surface texture"); 
            return;
        }

        let backbuffer = surfaceTexture.texture.createView();
        if !backbuffer { 
            fmt.println("Failed to create texture view"); 
            return;
        }

        let encoder = this.device.createCommandEncoder();
        if !encoder { 
            fmt.println("Failed to create command encoder"); 
            return;
        }

        this.queue.writeBuffer<inline Globals>(this.globalsBuffer, [](inline Globals) {
            {
                screenSize: Vec2f(
                    this.windowSize.x as f32,
                    this.windowSize.y as f32
                ),
            }
        });

        let quadVertices = [](inline QuadVertex) {
            { pos: Vec2f(-0.5, -0.5) },
            { pos: Vec2f(0.5, -0.5) },
            { pos: Vec2f(0.5, 0.5) },
            { pos: Vec2f(-0.5, 0.5) },
        }
        let quadVertexBuffer = this.device.createBuffer({
            usage: wgpu.BufferUsage.Vertex | wgpu.BufferUsage.CopyDst,
            size: sizeof(type<inline QuadVertex>) * 4,
        });
        this.queue.writeBuffer<inline QuadVertex>(quadVertexBuffer, quadVertices);

        let primitives = [](inline PrimitiveInstance) {
            {
                type: 0,
                pos: Vec2f(200, 200),
                size: Vec2f(100, 100),
                fillColor: Colorf(1, 0, 0, 1),
                borderColor: Colorf(0, 1, 0, 0),
                borderThickness: 1,
                radius: 100,
            },
            {
                type: 0,
                pos: Vec2f(200, 400),
                size: Vec2f(100, 100),
                fillColor: Colorf(1, 0, 0, 1),
                borderColor: Colorf(0, 1, 0, 0),
                borderThickness: 2,
                radius: 100,
            },
            {
                type: 0,
                pos: Vec2f(200, 600),
                size: Vec2f(100, 100),
                fillColor: Colorf(1, 0, 0, 1),
                borderColor: Colorf(0, 1, 0, 0),
                borderThickness: 3,
                radius: 100,
            },
            {
                type: 0,
                pos: Vec2f(800, 200),
                size: Vec2f(200, 200),
                fillColor: Colorf(0, 0, 1, 1),
                borderColor: Colorf(0, 1, 0, 0),
                borderThickness: 1,
                radius: 20,
            }
        };

        let instanceBuffer = this.device.createBuffer({
            size: sizeof(type<inline PrimitiveInstance>) * primitives.length,
            usage: wgpu.BufferUsage.Vertex | wgpu.BufferUsage.Storage | wgpu.BufferUsage.CopyDst,
        });
        this.queue.writeBuffer<inline PrimitiveInstance>(instanceBuffer, primitives);

        let colorAttachment = wgpu.RenderPassColorAttachment {
            view: backbuffer,
            clearValue: Color(0, 0, 0, 0),
            loadOp: wgpu.LoadOp.Clear,
            storeOp: wgpu.StoreOp.Store,
        };

        let renderPassDescriptor = wgpu.RenderPassDescriptor {
            colorAttachments: {
                colorAttachment,
            },
        };
        let renderPass = encoder.beginRenderPass(renderPassDescriptor);
        if !renderPass { 
            fmt.println("Failed to create render pass"); 
            return;
        }

        renderPass.setPipeline(this.pipeline);
        // renderPass.setVertexBuffer(0, this.vertexBuffer);
        renderPass.setVertexBuffer(0, quadVertexBuffer);

        renderPass.setBindGroup(0, this.globalsBindGroup);

        renderPass.setViewport(0, 0, this.windowSize.x as real, this.windowSize.y as real, 0.0, 1.0);
        renderPass.setScissorRect(0, 0, this.windowSize.x, this.windowSize.y);

        renderPass.setIndexBuffer(this.indexBuffer, wgpu.IndexFormat.Uint32);
        renderPass.setVertexBuffer(1, instanceBuffer);

        renderPass.drawIndexed(this.commands.indices.length, primitives.length, 0, 0, 0);

        // SDF rendering
        // renderPass.draw(4, primitives.length, 0, 0); // 4 vertices per instance

        renderPass.end();

        let commandBuffer = encoder.finish();
        if !commandBuffer { 
            fmt.println("Failed to finish render pass and get command buffer"); 
            return;
        }

        this.queue.submit({ commandBuffer });
        if !this.surface.present() {
            fmt.println("Surface present failed");
            return;
        }
    }
}

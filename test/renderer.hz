
struct Vertex {
    pos: inline Vec3f = {};
    color: inline Colorf = {};
}

struct DrawCommands {
    vertices: [](inline Vertex) = [];
    indices: []u32 = [];
}

struct Globals {
    screenSize: inline Vec2f;
}

max<T>(a: T, b: T): T => {
    if a >= b {
        return a;
    }
    return b;
}

min<T>(a: T, b: T): T => {
    if a <= b {
        return a;
    }
    return b;
}

struct PrimitiveInstance {
    pos: inline Vec2f;            // center position in pixels
    size: inline Vec2f;           // width/height
    radius: f32;           // corner radius for rounded rect
    borderThickness: f32;  // 0 = no border
    fillColor: inline Colorf;
    borderColor: inline Colorf;
    type: u32;             // 0 = Filled Rounded Rectangle, 1 = Outlined Rounded Rectangle
};

struct QuadVertex {
    pos: inline Vec2f;  // [-0.5, -0.5] .. [0.5, 0.5]
};

opaque struct Renderer {
    windowSize: Vec2i;
    queue: mut wgpu.Queue;
    device: mut wgpu.Device;
    surface: mut wgpu.Surface;
    pipeline: mut wgpu.RenderPipeline;
    globalsBuffer: mut wgpu.Buffer;
    globalsBindGroup: mut wgpu.BindGroup;

    vertexBuffer: mut wgpu.Buffer;
    indexBuffer: mut wgpu.Buffer;

    primitives: []inline PrimitiveInstance = [];

    constructor(size: Vec2i, device: mut wgpu.Device, surface: mut wgpu.Surface, surfaceFormats: []wgpu.TextureFormat) {
        let queue = device.getQueue();
        if !queue { 
            sys.panic("Failed to get queue");
        }

        let vertexLayout = wgpu.VertexBufferLayout {
            arrayStride: sizeof(type<inline QuadVertex>),
            stepMode: wgpu.VertexStepMode.Vertex,
            attributes: {
                {
                    shaderLocation: 0,
                    offset: 0,
                    format: wgpu.VertexFormat.Float32x2,
                },
            },
        };

        let instanceLayout = wgpu.VertexBufferLayout {
            arrayStride: sizeof(type<inline PrimitiveInstance>),
            stepMode: wgpu.VertexStepMode.Instance, // key! this is per-instance
            attributes: {
                { shaderLocation: 1, offset: 0, format: wgpu.VertexFormat.Float32x2 }, // pos
                { shaderLocation: 2, offset: 8, format: wgpu.VertexFormat.Float32x2 }, // size
                { shaderLocation: 3, offset: 16, format: wgpu.VertexFormat.Float32 },   // radius
                { shaderLocation: 4, offset: 20, format: wgpu.VertexFormat.Float32 },   // borderThickness
                { shaderLocation: 5, offset: 24, format: wgpu.VertexFormat.Float32x4 }, // fillColor
                { shaderLocation: 6, offset: 40, format: wgpu.VertexFormat.Float32x4 }, // borderColor
                { shaderLocation: 7, offset: 56, format: wgpu.VertexFormat.Uint32 },    // type
            },
        };

        let globalsLayout = device.createBindGroupLayout({
            entries: {
                {
                    binding: 0,
                    visibility: wgpu.ShaderStage.Vertex,
                    buffer: { type: wgpu.BufferBindingType.Uniform },
                },
            },
        });

        let globalsBuffer = device.createBuffer({
            usage: wgpu.BufferUsage.Uniform | wgpu.BufferUsage.CopyDst,
            size: sizeof(type<inline Globals>),
        });

        let globalsBindGroup = device.createBindGroup({
            layout: globalsLayout,
            entries: {
                {
                    binding: 0,
                    buffer: globalsBuffer,
                    offset: 0,
                    size: sizeof(type<inline Globals>),
                },
            },
        });

        let pipelineLayout = device.createPipelineLayout({
            bindGroupLayouts: { globalsLayout },
        });

        let code = fs.readFile("test/shaders.wgsl");
        assert(code);
        let shader = g_device.createShaderModule({
            code: code,
        });

        let pipeline = device.createRenderPipeline({
            layout: pipelineLayout,
            vertex: {
                module: shader,
                entryPoint: "vs_main",
                buffers: { vertexLayout, instanceLayout },
            },
            fragment: {
                module: shader,
                entryPoint: "fs_main",
                targets: {
                    { 
                        format: surfaceFormats[0],
                        blend: {
                            color: {
                                srcFactor: wgpu.BlendFactor.SrcAlpha,
                                dstFactor: wgpu.BlendFactor.OneMinusSrcAlpha,
                                operation: wgpu.BlendOperation.Add,
                            },
                            alpha: {
                                srcFactor: wgpu.BlendFactor.One,
                                dstFactor: wgpu.BlendFactor.OneMinusSrcAlpha,
                                operation: wgpu.BlendOperation.Add,
                            },
                        },
                    },
                },
            },
            primitive: {
                topology: wgpu.PrimitiveTopology.TriangleList,
            },
        });

        let vertexBuffer = device.createBuffer({
            usage: wgpu.BufferUsage.Vertex | wgpu.BufferUsage.CopyDst,
            size: sizeof(type<inline QuadVertex>) * 4,
        });
        queue.writeBuffer<inline QuadVertex>(vertexBuffer, [
            { pos: Vec2f(-0.5, -0.5) },
            { pos: Vec2f(0.5, -0.5) },
            { pos: Vec2f(0.5, 0.5) },
            { pos: Vec2f(-0.5, 0.5) },
        ]);

        let indexBuffer = device.createBuffer({
            usage: wgpu.BufferUsage.Index | wgpu.BufferUsage.CopyDst,
            size: sizeof(u32) * 6,
        });
        queue.writeBuffer<u32>(indexBuffer, [0, 1, 2, 0, 2, 3]);

        return Renderer {
            windowSize: size,
            device: device,
            queue: queue,
            surface: surface,
            pipeline: pipeline,
            vertexBuffer: vertexBuffer,
            indexBuffer: indexBuffer,
            globalsBuffer: globalsBuffer,
            globalsBindGroup: globalsBindGroup,
        };
    }

    struct TriangleVertex {
        pos: Vec2;
        color: Color;
    };

    struct RectOpts {
        pos: Vec2;
        size: Vec2;
        fillColor: Color = { r: 1, g: 1, b: 1, a: 1 };
        cornerRadius: real = 0;
        borderColor: Color = { r: 1, g: 1, b: 1, a: 1 };
        borderThickness: real = 0;
    };

    drawRect(opts: RectOpts) {
        if opts.fillColor.a != 0.0 {
            this.primitives.push({
                type: 0, // Filled Rounded Rectangle
                pos: { x: (opts.pos.x + opts.size.x / 2.0) as f32, y: (opts.pos.y + opts.size.y / 2.0) as f32 },
                size: { x: opts.size.x as f32, y: opts.size.y as f32 },
                radius: opts.cornerRadius as f32,
                borderThickness: 0,
                fillColor: {
                    r: opts.fillColor.r as f32,
                    g: opts.fillColor.g as f32,
                    b: opts.fillColor.b as f32,
                    a: opts.fillColor.a as f32,
                },
                borderColor: { r: 0, g: 0, b: 0, a: 0 },
            });
        }
        if opts.borderColor.a != 0.0 && opts.borderThickness > 0.0 {
            this.primitives.push({
                type: 1, // Outlined Rounded Rectangle
                pos: { x: (opts.pos.x + opts.size.x / 2.0) as f32, y: (opts.pos.y + opts.size.y / 2.0) as f32 },
                size: { x: opts.size.x as f32, y: opts.size.y as f32 },
                radius: opts.cornerRadius as f32,
                borderThickness: opts.borderThickness as f32,
                fillColor: { r: 0, g: 0, b: 0, a: 0 },
                borderColor: {
                    r: opts.borderColor.r as f32,
                    g: opts.borderColor.g as f32,
                    b: opts.borderColor.b as f32,
                    a: opts.borderColor.a as f32,
                },
            });
        }
    }

    beginFrame() {
        this.primitives = [];
    }

    endFrame() {
        let surfaceTexture = this.surface.getCurrentTexture();
        if !surfaceTexture.texture { 
            fmt.println("Failed to get surface texture"); 
            return;
        }

        let backbuffer = surfaceTexture.texture.createView();
        if !backbuffer { 
            fmt.println("Failed to create texture view"); 
            return;
        }

        let encoder = this.device.createCommandEncoder();
        if !encoder { 
            fmt.println("Failed to create command encoder"); 
            return;
        }

        this.queue.writeBuffer<inline Globals>(
            this.globalsBuffer,
            [
                {
                    screenSize: Vec2f(
                        this.windowSize.x as f32,
                        this.windowSize.y as f32
                    ),
                }
            ]
        );

        let instanceBuffer = this.device.createBuffer({
            size: sizeof(type<inline PrimitiveInstance>) * this.primitives.length,
            usage: wgpu.BufferUsage.Vertex | wgpu.BufferUsage.Storage | wgpu.BufferUsage.CopyDst,
        });
        this.queue.writeBuffer<inline PrimitiveInstance>(instanceBuffer, this.primitives);

        let colorAttachment = wgpu.RenderPassColorAttachment {
            view: backbuffer,
            clearValue: Color(0, 0, 0, 0),
            loadOp: wgpu.LoadOp.Clear,
            storeOp: wgpu.StoreOp.Store,
        };

        let renderPassDescriptor = wgpu.RenderPassDescriptor {
            colorAttachments: {
                colorAttachment,
            },
        };
        let renderPass = encoder.beginRenderPass(renderPassDescriptor);
        if !renderPass { 
            fmt.println("Failed to create render pass"); 
            return;
        }

        renderPass.setPipeline(this.pipeline);
        renderPass.setVertexBuffer(0, this.vertexBuffer);

        renderPass.setBindGroup(0, this.globalsBindGroup);

        renderPass.setViewport(0, 0, this.windowSize.x as real, this.windowSize.y as real, 0.0, 1.0);
        renderPass.setScissorRect(0, 0, this.windowSize.x, this.windowSize.y);

        renderPass.setIndexBuffer(this.indexBuffer, wgpu.IndexFormat.Uint32);
        renderPass.setVertexBuffer(1, instanceBuffer);

        renderPass.drawIndexed(6, this.primitives.length, 0, 0, 0);

        renderPass.end();

        let commandBuffer = encoder.finish();
        if !commandBuffer { 
            fmt.println("Failed to finish render pass and get command buffer"); 
            return;
        }

        this.queue.submit({ commandBuffer });
        if !this.surface.present() {
            fmt.println("Surface present failed");
            return;
        }
    }
}

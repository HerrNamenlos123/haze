
// import math
// import glDraw
// import glfw
// import gl

// foo(arena: Arena): Arena& {
//     return arena;
// }

struct Foo {};

// struct Ref<T> {
//     ref: T&;
// }

main(): int {

    builtin.printf("Hello world!\n");

    // let foo = Foo {};
    // let newFoo = Foo {};

    // let a: const &const int = uninitialized;
    // let b: mut &int = uninitialized;
    // let c: []int = uninitialized;
    // let d: const []const int = uninitialized;
    // let e: mut []&mut int = uninitialized;

    // let x = 0;
    // let y: &int = x;
    // const z: &int = y;

    // a = 5;

    // let a: Foo& = foo;

    // assign(a, newFoo);
    // reassign(a, newFoo);

    // let arena = Arena();
    // const s = fmt.format<int>(arena, -7183, {});

    // print("Formatted: ");
    // println(s);
    // let a = f"Test: {Vec3 {}} other";

    // let arena = Arena();
    // let b: Arena& = arena;

    // let vec1 = arena.alloc<Vec3>({ x: 1.0, y: 2.0, z: 3.0 });
    // let vec2 = arena.alloc<Vec3>({ x: 4.0, y: 5.0, z: 6.0 });

    // println("Vec 1: ", vec1);
    // println("Vec 2: ", vec2);

    return 0;

    // println("TODO: Fix the situation for negative literals. Parsing the minus is bad as it's punctiation dependent. It should be changed to parse as a Unary Expression with positive Literal, and in the symbol collection, Unary+Literal can be caught and converted into literal with negative value.");
    // println("TODO: All Increment operations and short-hand syntax should be expanded into proper full assignment expressions, and then compiled normally, makes everything much simpler, especially the overflow tracking.");

    // if !glfw.init() {
    //     return 0;
    // }

    // const window = glfw.createWindow({ 
    //     title: "Hello World!",
    // });

    // window.swapInterval(0);
    // gl.init(glfw.getProcAddress());

    // gl.viewport(0, 0, 1920, 1080);

    // let oldTime = glfw.getTime();
    // window.swapBuffers();

    // let frameCounter: i16 = 0;

    // let fps = 0.0;
    // while !window.shouldClose() {
    //     glfw.pollEvents();

    //     let now = glfw.getTime();
    //     let elapsed = now - oldTime;
    //     oldTime = now;

    //     gl.clearColor(Color((math.sin(oldTime * 10.0) + 1.0) / 2.0, 0.1, 0.1, 1.0));
    //     gl.clear();

    //     if fps == 0.0 {
    //         fps = 1.0 / elapsed;
    //     }

    //     let alpha = 0.001;
    //     fps = fps * (1.0 - alpha) + 1.0 / elapsed * alpha;

    //     println("FPS:", fps);
    //     println("Count: ", frameCounter);

    //     window.swapBuffers();
    // }

    // glfw.terminate();

    return 0;
}


import math
import glfw
import gl
import wgpu
import glfw_wgpu

let g_adapter = none as mut wgpu.Adapter | none;
let g_adapterReady = false;

export extern C noemit wgpu_init(glfwWindow: cptr) :: final;
export extern C wgpu_start(glfwWindow: cptr, device: wgpu.ffi.WGPUDeviceImpl, surface: wgpu.ffi.WGPUSurfaceImpl, queue: wgpu.ffi.WGPUQueueImpl, texture: wgpu.ffi.WGPUTextureViewImpl) :: final;
export extern C wgpu_end(glfwWindow: cptr) :: final;

adapterRequestCallback(status: wgpu.RequestAdapterStatus, adapter: mut wgpu.Adapter, message: str): void {
  if (status == wgpu.RequestAdapterStatus.Success) {
    g_adapter = adapter;
    g_adapterReady = true;
    fmt.println("Adapter request successful");
  }
  else {
    g_adapterReady = true;
    fmt.println("Adapter request failed");
  }
}

let g_device = none as mut wgpu.Device | none;
let g_deviceReady = false;

deviceRequestCallback(status: wgpu.RequestDeviceStatus, device: mut wgpu.Device, message: str): void {
  if (status == wgpu.RequestDeviceStatus.Success) {
    g_device = device;
    g_deviceReady = true;
    fmt.println("Device request successful");
  }
  else {
    g_deviceReady = true;
    fmt.println("Device request failed");
  }
}

let g_queue = none as mut wgpu.Queue | none;

main(): int {
    attempt {
        if !glfw.init() { raise "GLFW init failed"; }

        const window = glfw.createWindow({ 
            title: "WebGPU Example",
            noApi: true,
        });
        if !window { raise "Window creation failed"; }

        let instance = wgpu.createInstance();
        if !instance { raise "WGPU Instance creation failed"; }

        let surface = glfw_wgpu.createWindowWGPUSurface(instance, window);
        if !surface { raise "WGPU Surface creation failed"; }

        instance.requestAdapter({}, { callback: adapterRequestCallback });

        let timeout = 100;
        while !g_adapterReady && timeout > 0 {
            time.sleep(0.1);
            timeout--;
        }
        if (!g_adapter) { raise "Failed to get adapter after timeout"; }

        g_adapter.requestDevice({}, { callback: deviceRequestCallback });

        timeout = 100;
        while !g_deviceReady && timeout > 0 {
            time.sleep(0.1);
            timeout--;
        }
        if (!g_device) { raise "Failed to get device after timeout"; }

        g_queue = g_device.getQueue()?!;
        if (!g_queue) { raise "Failed to get queue"; }

        let caps = surface.getCapabilities(g_adapter);
        if (!caps) { raise "Failed to get surface capabilities"; }

        let surfaceFormat = caps.formats[0];

        let size = window.getFramebufferSize();
        fmt.println("Format", size.x, size.y);

        surface.configure({
            device: g_device,
            format: surfaceFormat,
            usage: wgpu.TextureUsage.RenderAttachment,
            width: size.x as u32,
            height: size.y as u32,
            presentMode: wgpu.PresentMode.Fifo,
            alphaMode: caps.alphaModes[0],
        });

        let shadercode = fs.readFile("test/shaders.wgsl")?!;
        let shader = g_device.createShaderModule({
            code: shadercode,
        });

        // let vertices = [
        //     vec2(-0.5, -0.5),
        //     vec2( 0.5, -0.5),
        //     vec2( 0.5,  0.5),

        //     vec2(-0.5, -0.5),
        //     vec2( 0.5,  0.5),
        //     vec2(-0.5,  0.5),
        // ];

        // let vertexBuffer = g_device.createBuffer({
        //     usage: wgpu.BufferUsage.Vertex | wgpu.BufferUsage.CopyDst,
        //     size: sizeof(vertices),
        // });
        // g_queue.writeBuffer(vertexBuffer, 0, vertices);

        // let vertexLayout = wgpu.VertexBufferLayout {
        //     arrayStride: sizeof(vec2),
        //     stepMode: wgpu.VertexStepMode.Vertex,
        //     attributes: {
        //         {
        //             shaderLocation: 0,
        //             offset: 0,
        //             format: wgpu.VertexFormat.Float32x2,
        //         },
        //     },
        // };

        // let pipeline = g_device.createRenderPipeline({
        //     vertex: {
        //         module: shader,
        //         entryPoint: "vs_main",
        //         buffers: { vertexLayout },
        //     },
        //     fragment: {
        //         module: shader,
        //         entryPoint: "fs_main",
        //         targets: {
        //             { format: surfaceFormat },
        //         },
        //     },
        //     primitive: {
        //         topology: wgpu.PrimitiveTopology.TriangleList,
        //     },
        // });

        while !window.shouldClose() {
            glfw.pollEvents();

            let surfaceTexture = surface.getCurrentTexture();
            let tex = surfaceTexture.texture;
            if !tex { raise "Failed to get surface texture"; }

            let backbuffer = tex.createView();
            if !backbuffer { raise "Failed to create texture view"; }

            let encoder = g_device.createCommandEncoder();
            if !encoder { raise "Failed to create command encoder"; }

            let colorAttachment = wgpu.RenderPassColorAttachment {
                view: backbuffer,
                clearValue: Color(0.8, 0.1, 0.1, 0.1),
                loadOp: wgpu.LoadOp.Clear,
                storeOp: wgpu.StoreOp.Store,
            };

            let renderPassDescriptor = wgpu.RenderPassDescriptor {
                colorAttachments: {
                    colorAttachment,
                },
            };
            let renderPass = encoder.beginRenderPass(renderPassDescriptor);
            if !renderPass { raise "Failed to create render pass"; }

            // renderPass.setPipeline(pipeline);
            // renderPass.setVertexBuffer(0, vertexBuffer);
            // renderPass.draw(6, 1, 0, 0);

            renderPass.end();
            let commandBuffer = encoder.finish();
            if !commandBuffer { raise "Failed to finish render pass and get command buffer"; }

            g_queue.submit({ commandBuffer });
            if !surface.present() {
                raise "Surface present failed";
            }
        }

        window.destroy();
        glfw.terminate();
        
        return 0;
    }
    else e {
        if e is str {
            fmt.println("Application failed: ", e);
        }
        else if e is fs.Error {
            fmt.println("Application failed: ", e);
        }
        else if e is none {
            fmt.println("Application failed: ", e);
        }
        else {
            fmt.println("Application failed: ", e);
        }
        return 1;
    }

    // fmt.println("TODO: Implement a proper platform configuration system. Currently there is an interface.compiler.defines feature to define transitive macros, but this is not the solution, it is only a workaround. We rather want a real, proper configuration system where we can e.g. differentiate between x11 and wayland platform configurations and compile for one of them.");

//     fmt.println("TODO: Fix returns, if function returns in one path but not all, it must either create an error or automatically return none");
//     fmt.println("Idea for later: (from Prime Reacts: The Flaws of Inheritance): I should implement interfaces as a way to make a contract about generic types, and to make the interfaces very powerful, interfaces should be able to define members and methods, as well as default implementations of methods that is used if the struct does not provide that function, and it is allowed as long as the default implementation of the interface method only uses other methods of the interface. This makes it very powerful and a complete replacement for polymorphism.");
//     fmt.println("Idea: Implement scopes/do blocks/whatever, and like in Swift make the ability to label them, and then 'break foo' can be used to break out of that scope, which is awesome because it greatly simplifies the common issue of having 2 nested loops and wanting to break out of the outer one.")

//     if !glfw.init() {
//         return 0;
//     }

//     const window = glfw.createWindow({ 
//         title: "Hello World!",
//     });

//     if window {
//         window.swapInterval(0);
//         gl.init(glfw.getProcAddress());

//         gl.viewport(0, 0, 1920, 1080);

//         let oldTime = glfw.getTime();
//         window.swapBuffers();

//         let frameCounter: i16 = 0;

//         let fps = 0.0;
//         while !window.shouldClose() {
//             glfw.pollEvents();

//             let now = glfw.getTime();
//             let elapsed = now - oldTime;
//             oldTime = now;

//             gl.clearColor(Color((math.sin(oldTime * 10.0) + 1.0) / 2.0, 0.1, 0.1, 1.0));
//             gl.clear();

//             if fps == 0.0 {
//                 fps = 1.0 / elapsed;
//             }

//             let alpha = 0.001;
//             fps = fps * (1.0 - alpha) + 1.0 / elapsed * alpha;

//             fmt.println("FPS:", fps);
//             fmt.println("Count: ", frameCounter);

//             window.swapBuffers();
//         }

//         glfw.terminate();
//     }

//     return 0;
}

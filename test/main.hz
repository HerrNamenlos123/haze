
import math
// import glDraw
import glfw
import gl

// foo(arena: Arena): Arena& {
//     return arena;
// }

// struct Foo
//     requires LT(this.x) >= LT(this)
// {
//     x: int = 0;
//     y: int = 0;
//     z: int = 0;
// };

// struct Ref<T> {
//     ref: T&;
// }

// foo(arr: Slice<int>, other: Iter<const Foo>) {

// }

struct Bar {};
struct Baz {};

struct Foo {
    bar: Bar;
    baz: Baz;
}

struct Node {
    name: str;
    left: Node | none;
    right: Node | none;
}

makeNode(name: str) {
    return Node { name: name };
}

buildTree(tree: mut Node) {
    tree.left = makeNode("Left");
    tree.right = makeNode("Right");
}

printTree(tree: Node, indent = 0): void {
    fmt.println(f"Node: {tree.name}");
    fmt.println(f"  left: ");
    printTree(tree.left, indent + 4);
    fmt.println(f"  right: ");
    printTree(tree.right, indent + 4);
}

tree() {
    let tree = makeNode("Root");
    buildTree(tree);
    printTree(tree);
}

makeNodeRaw(arena: Arena, name: str) :: noalloc {
    return Node { name: name } in arena;
}

bar() {
    let makeNodeFunc: () => Node | none = makeNode;

    const node = makeNodeFunc("Test");

    let ar = fn.localArena;
    const other = makeNodeFunc("Other") in ar;

    let makeNodeRawFunc: () => Node | none :: noalloc = makeNodeRaw;
    const other2 = makeNodeRawFunc(fn.returnArena, "other2");
}

fooz(): Bar {
    const foo = Foo { bar: Bar {}, baz: {} };
    foo.bar = Bar {};
    // __c__("a");
    return foo.bar;
}

main(): int {

    println("TODO for next time: Refactor type system: Need some way to have partial, non-canonical types for functions, that mutate as we go along, and when function is done, can be replaced with a canonical version. But everything that depends on it, must change too. So need some sort of non-canonical type indirection. Absolutely need a way to do this for allocation inference, and then return type inference works automatically too. When done, function types need full support for requires block, allocation and lifetime constraints etc, and then that info in the function type can be used to actually call the function in lowering.");
    println("TODO: Look at fooz(). Escape analysis works, now test it a bit and then implement the arena selection based on the escape analysis, and to track which functions even need arenas, etc.");

    // let array: mut []u8 = [];

    // assign(a, newFoo);
    // rebind(a, newFoo);

    // let arena = Arena();
    // const s = fmt.format<int>(arena, -7183, {});
    // const foo1 = arena.alloc<Foo>({ x: 1, y: 2, z: 3});
    // const foo2 = arena.alloc<Foo>({ x: 4, y: 5, z: 6});
    // const foo3 = arena.alloc<Foo>({ x: 7, y: 8, z: 9});
    // println(s);
    // arena.free();

    // print("Formatted: ");
    // println(s);
    // let a = f"Test: {Vec3 {}} other";

    // let arena = Arena();
    // let b: Arena& = arena;

    // let vec1 = arena.alloc<Vec3>({ x: 1.0, y: 2.0, z: 3.0 });
    // let vec2 = arena.alloc<Vec3>({ x: 4.0, y: 5.0, z: 6.0 });

    // println("Vec 1: ", vec1);
    // println("Vec 2: ", vec2);

    return 0;

    println("TODO: All Increment operations and short-hand syntax should be expanded into proper full assignment expressions, and then compiled normally, makes everything much simpler, especially the overflow tracking.");
    println("Idea for later: (from Prime Reacts: The Flaws of Inheritance): I should implement interfaces as a way to make a contract about generic types, and to make the interfaces very powerful, interfaces should be able to define members and methods, as well as default implementations of methods that is used if the struct does not provide that function, and it is allowed as long as the default implementation of the interface method only uses other methods of the interface. This makes it very powerful and a complete replacement for polymorphism.");
    println("Idea: Implement scopes/do blocks/whatever, and like in Swift make the ability to label them, and then 'break foo' can be used to break out of that scope, which is awesome because it greatly simplifies the common issue of having 2 nested loops and wanting to break out of the outer one.")

    if !glfw.init() {
        return 0;
    }

    const window = glfw.createWindow({ 
        title: "Hello World!",
    });

    if window {
        window.swapInterval(0);
        gl.init(glfw.getProcAddress());

        gl.viewport(0, 0, 1920, 1080);

        let oldTime = glfw.getTime();
        window.swapBuffers();

        let frameCounter: i16 = 0;

        let fps = 0.0;
        while !window.shouldClose() {
            glfw.pollEvents();

            let now = glfw.getTime();
            let elapsed = now - oldTime;
            oldTime = now;

            gl.clearColor(Color((math.sin(oldTime * 10.0) + 1.0) / 2.0, 0.1, 0.1, 1.0));
            gl.clear();

            if fps == 0.0 {
                fps = 1.0 / elapsed;
            }

            let alpha = 0.001;
            fps = fps * (1.0 - alpha) + 1.0 / elapsed * alpha;

            println("FPS:", fps);
            println("Count: ", frameCounter);

            window.swapBuffers();
        }

        glfw.terminate();
    }

    return 0;
}

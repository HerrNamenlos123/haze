
enum ETokenType {
    Identifier,
    Integer,
    Float,
    String,

    LParen, RParen,
    LBrace, RBrace,
    Comma, Dot, Semicolon,
    Plus, Minus, Asterisk, Slash, Percent,
    Equals,

    EqualsEquals,
    BangEquals,

    Let,
    If,
    Else,
    While,
    For,
    Return,

    EOF,
}

struct IntegerToken {
    value: int;
}

struct IdentifierToken {
    name: str;
}

type Token = IntegerToken | IdentifierToken;

stringify(token: Token) {
    if token is IntegerToken {
        return f"IntegerToken(\"{token.value}\")";
    }
    else if token is IdentifierToken {
        return f"IdentifierToken(\"{token.name}\")";
    }
    return "";
}

struct Lexer {
    src: str;
    cursor: int = 0;

    peek() {
        if this.cursor >= this.src.length { return null; }
        return this.src[this.cursor];
    }

    advance() {
        let chr = this.peek();
        if chr { this.cursor++; }
        return chr;
    }

    nextToken(): Token | null {
        while let b = this.peek(); ascii.isWhitespace(b) {
            this.advance();
        }

        if let b = this.peek() {
            if ascii.isDigit(b) {
                return this.parseInteger();
            }
            if ascii.isAlpha(b) {
                return this.parseIdentifier();
            }
            sys.panic("unexpected character");
        }

        return null;
    }

    parseInteger(): Token {
        let start = this.cursor;
        let value: int = 0;

        while let b = this.peek(); ascii.isDigit(b) {
            value = value * 10 + (b - b"0") as int;
            this.advance();
            b = this.peek();
        }

        return IntegerToken {
            value: value
        };
    }

    parseIdentifier(): Token {
        let start = this.cursor;

        while let b = this.peek(); ascii.isAlpha(b) || ascii.isDigit(b) || b == b"_" {
            this.advance();
            b = this.peek();
        }

        let name = this.src.substr(start, this.cursor);

        return IdentifierToken {
            name: name
        };
    }
}

extern C parse(source: str) {
    const result = fs.read(source);
    if result {
        let lexer = Lexer {
            src: result,
        };

        // fmt.println("TODO for next time: Fix the union lowering error below, and implement while let for if statements. Then, think about some graphical application for SDL.")

        while let tok = lexer.nextToken() {
            fmt.println(stringify(tok));
            tok = lexer.nextToken()
        }
    }
    else {
        fmt.println("Failed");
    }
}

main() {
    parse("stdlib/core/src/String.hz");
    return 0;
}

struct List<T> {
  buffer: Memory.Buffer;
  length: u64;

  constructor(): List<T> {
    const initialCapacity = 4;
    return List<T> {
      .buffer: Memory.Buffer(initialCapacity * sizeof<T>),
      .length: 0,
    };
  }

  reserve(size: u64): none {
    if size <= this.capacity() {
      return;
    }
    this.buffer.resize(size * sizeof<T>);
  }

  push(n: T) {
    if this.length >= this.capacity() {
      this.reserve(this.length * 2);
    }
    const buf = this.buffer.data as RawPtr<T>;
    __c__("buf[this->length] = n");
    this.length = this.length + 1;
  }

  pop(): T {
    const back = this.get(this.length - 1);
    this.length = this.length - 1;
    return back;
  }

  get(n: u64): T {
    if n < 0 or n >= this.length {
      System.panic("OUT OF BOUNDS");
    }
    const buf = this.buffer.data as RawPtr<T>;
    const result: T;
    __c__("result = buf[n]");
    return result;
  }

  capacity(): u64 {
    return this.buffer.size / sizeof<T>;
  }

  clear() {
    this.length = 0;
  }
}

export struct Result<TSuccess, TError> {
  unsafe_union {
    success: TSuccess;
    error: TError;
  }
  isSuccess: boolean;
}

export struct List<_List_T> {
  buffer: Memory.Buffer;
  length: u64;

  constructor(): List<_List_T> {
    const initialCapacity = 4;
    return List<_List_T> {
      .buffer: Memory.Buffer(initialCapacity * sizeof<_List_T>),
      .length: 0,
    };
  }

  reserve(size: u64): none {
    if size <= this.capacity() {
      return;
    }
    this.buffer.resize(size * sizeof<_List_T>);
  }

  push(n: _List_T) {
    if this.length >= this.capacity() {
      this.reserve(this.length * 2);
    }
    const buf = this.buffer.data as RawPtr<_List_T>;
    __c__("buf[this->length] = n");
    this.length = this.length + 1;
  }

  pop(): _List_T {
    const back = this.get(this.length - 1);
    this.length = this.length - 1;
    return back;
  }

  get(n: u64): _List_T {
    if n < 0 or n >= this.length {
      System.panic("OUT OF BOUNDS");
    }
    const buf = this.buffer.data as RawPtr<_List_T>;
    const result: _List_T;
    __c__("result = buf[n]");
    return result;
  }

  capacity(): u64 {
    return this.buffer.size / sizeof<_List_T>;
  }

  clear() {
    this.length = 0;
  }
}

export struct String {
  
}

extern "C" calloc(num: u64, size: u64): RawPtr<none>;
extern "C" realloc(ptr: RawPtr<none>, newSize: u64): RawPtr<none>;
extern "C" free(ptr: RawPtr<none>);
extern "C" memcpy(to: RawPtr<none>, from: RawPtr<none>, length: u64): RawPtr<none>;

export struct Array<T, Size> {
  length: u64;
  data: __C_Array<i32, 5>;
}

export namespace Memory {

  extern const DEFAULT_ARENA_SIZE = 16 * 1024;

  generalPurposeMalloc(size: u64): RawPtr<none> {
    return calloc(1, size);
  }

  generalPurposeFree(ptr: RawPtr<none>) {
    free(ptr);
  }

  copy(to: RawPtr<none>, from: RawPtr<none>, length: u64) {
    memcpy(to, from, length);
  }

  struct ArenaChunk {
    nextChunk: RawPtr<ArenaChunk>;
    capacity: u64;
    allocated: u64;
    data: RawPtr<none>;

    canAllocate(size: u64): boolean {
      const a: Array<i32, i32>;
      return this.allocated + size < this.capacity;
    }

    allocate(size: u64): RawPtr<none> {
      if this.allocated + size >= this.capacity {
        System.panic("ArenaChunk was instructed to allocate, but it is too small");
      }
      const ptr = 0 as RawPtr<none>;
      __c__("ptr = &(this->data) + this->allocated;");
      this.allocated += size;
      return ptr;
    }
  }

  struct Arena {
    firstChunk: RawPtr<ArenaChunk>;

    init() {
      if this.firstChunk {
        System.panic("Arena is already initialized");
      }
      const totalSize = Memory.DEFAULT_ARENA_SIZE + 2 * sizeof<u64> + sizeof<RawPtr<ArenaChunk>>;
      this.firstChunk = Memory.generalPurposeMalloc(totalSize) as RawPtr<ArenaChunk>;
      this.firstChunk.capacity = Memory.DEFAULT_ARENA_SIZE;
    }

    allocate(size: u64): RawPtr<none> {
      let chunk = this.firstChunk;
      while not chunk.canAllocate(size) {
        if not chunk.nextChunk {
          const totalSize = Memory.DEFAULT_ARENA_SIZE + 2 * sizeof<u64> + sizeof<RawPtr<ArenaChunk>>;
          chunk.nextChunk = Memory.generalPurposeMalloc(totalSize) as RawPtr<ArenaChunk>;
          chunk.nextChunk.capacity = Memory.DEFAULT_ARENA_SIZE;
        }
        chunk = chunk.nextChunk;
      }
      return chunk.allocate(size);
    }

    cleanup() {
      let chunk = this.firstChunk;
      while chunk {
        const next = chunk.nextChunk;
        Memory.generalPurposeFree(chunk);
        chunk = next;
      }
      this.firstChunk = 0 as RawPtr<ArenaChunk>;
    }
  }

  // struct Arena {
  //   __impl: ArenaImpl;

  //   constructor(): Arena {
  //     const arena: ArenaImpl;
  //     arena.init();
  //     return Arena<T> { .__impl: arena };
  //   }

  //   allocate(size: u64): RawPtr<none> {
  //     return this.__impl.allocate(size);
  //   }
  // }

  struct Buffer {
    data: RawPtr<none>;
    size: u64;

    constructor(size: u64): Memory.Buffer {
      const a = ctx;
      const buffer = Memory.generalPurposeMalloc(size);
      if !buffer {
        System.panic("Allocation failed");
      }
      return Memory.Buffer {
        .data: buffer,
        .size: size,
      };
    }

    resize(newSize: u64) {
      const newData = Memory.generalPurposeMalloc(newSize);
      if !newData {
        System.panic("Allocation failed");
      }
      Memory.copy(newData, this.data, this.size);
      this.size = newSize;
      this.data = newData;
    }
  }
}

namespace Memory {
  __setupMemoryContext() {
    ctx.mem.alloc = (size: u64): RawPtr<none> => {
      const arena = ctx.mem.globalDefaultArena as RawPtr<Arena>;
      return arena.allocate(size);
    };
    const arena = ctx.mem.globalDefaultArena as RawPtr<Arena>;
    arena.init();
  }
}

extern "C" calloc(num: u64, size: u64): RawPtr<none>;
extern "C" realloc(ptr: RawPtr<none>, newSize: u64): RawPtr<none>;
extern "C" free(ptr: RawPtr<none>);
extern "C" memcpy(to: RawPtr<none>, from: RawPtr<none>, length: u64): RawPtr<none>;

export namespace Memory {

  extern const DEFAULT_ARENA_SIZE = 16 * 1024;

  generalPurposeMalloc(size: u64): RawPtr<none> {
    return calloc(1, size);
  }

  generalPurposeFree(ptr: RawPtr<none>) {
    free(ptr);
  }

  copy(to: RawPtr<none>, from: RawPtr<none>, length: u64) {
    memcpy(to, from, length);
  }

  struct ArenaChunk {
    nextChunk: RawPtr<ArenaChunk>;
    size: u64;
    nextFreePointer: RawPtr<none>;
    data: RawPtr<none>;

    allocate(size: u64): RawPtr<none> {
      const ptr = this.nextFreePointer;
      __c__("this->nextFreePointer += size;");
      return ptr;
    }
  }

  struct ArenaImpl {
    firstChunk: RawPtr<ArenaChunk>;

    init() {
      if this.firstChunk {
        System.panic("Arena is already initialized");
      }
      // this.firstChunk = Memory.generalPurposeMalloc(Memory.DEFAULT_ARENA_SIZE + sizeof<u64> + 2 * sizeof<RawPtr<none>>);
    }

    // cleanup() {
    //   if this.data {
    //     Memory.release(this.data);
    //     this.data = 0 as RawPtr<none>;
    //     this.size = 0;
    //   }
    // }
  }

  struct Arena<T> {
    __impl: ArenaImpl;

    constructor(): Arena<T> {
      const arena: ArenaImpl;
      arena.init();
      return Arena<T> { .__impl: arena };
    }

    data(): RawPtr<T> {
      return this.__impl.data as RawPtr<T>;
    }

    size(): u64 {
      return this.__impl.size;
    }

    allocate(count: u64): RawPtr<T> {
      return this.__impl.allocate(count * sizeof<T>) as RawPtr<T>;
    }
  }

  struct Buffer {
    data: RawPtr<none>;
    size: u64;

    constructor(size: u64): Memory.Buffer {
      const a = ctx;
      const buffer = Memory.generalPurposeMalloc(size);
      if !buffer {
        System.panic("Allocation failed");
      }
      return Memory.Buffer {
        .data: buffer,
        .size: size,
      };
    }

    resize(newSize: u64) {
      const newData = Memory.generalPurposeMalloc(newSize);
      if !newData {
        System.panic("Allocation failed");
      }
      Memory.copy(newData, this.data, this.size);
      this.size = newSize;
      this.data = newData;
    }
  }
}
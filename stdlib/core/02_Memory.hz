
extern "C" calloc(num: u64, size: u64): RawPtr<none>;
extern "C" realloc(ptr: RawPtr<none>, newSize: u64): RawPtr<none>;
extern "C" free(ptr: RawPtr<none>);
extern "C" memcpy(to: RawPtr<none>, from: RawPtr<none>, length: u64): RawPtr<none>;

// export struct Array<T, Size> {
//   length: u64;
//   data: __C_Array<i32, Size>;
// }

export namespace Memory {

  generalPurposeMalloc(size: u64): RawPtr<none> {
    return calloc(1, size);
  }

  generalPurposeFree(ptr: RawPtr<none>) {
    free(ptr);
  }

  copy(to: RawPtr<none>, from: RawPtr<none>, length: u64) {
    memcpy(to, from, length);
  }

  struct ArenaChunk {
    nextChunk: RawPtr<ArenaChunk>;
    allocated: u64;
    data: __C_Array<u8, 16384>;

    capacity(): u64 {
      const cap = 0 as u64;
      __c__("cap = sizeof(this->data);");
      return cap;
    }

    canAllocate(size: u64): boolean {
      return this.allocated + size < this.capacity();
    }

    allocate(size: u64): RawPtr<none> {
      if this.allocated + size >= this.capacity() {
        System.panic("ArenaChunk was instructed to allocate, but it is too small");
      }
      const ptr = 0 as RawPtr<none>;
      __c__("ptr = &(this->data) + this->allocated;");
      this.allocated += size;
      return ptr;
    }
  }

  struct Arena {
    firstChunk: RawPtr<ArenaChunk>;

    init() {
      if this.firstChunk {
        System.panic("Arena is already initialized");
      }
      this.firstChunk = Memory.generalPurposeMalloc(sizeof<ArenaChunk>) as RawPtr<ArenaChunk>;
    }

    allocate(size: u64): RawPtr<none> {
      let chunk = this.firstChunk;
      while not chunk.canAllocate(size) {
        if not chunk.nextChunk {
          chunk.nextChunk = Memory.generalPurposeMalloc(sizeof<ArenaChunk>) as RawPtr<ArenaChunk>;
        }
        chunk = chunk.nextChunk;
      }
      return chunk.allocate(size);
    }

    cleanup() {
      let chunk = this.firstChunk;
      while chunk {
        const next = chunk.nextChunk;
        Memory.generalPurposeFree(chunk);
        chunk = next;
      }
      this.firstChunk = 0 as RawPtr<ArenaChunk>;
    }
  }

  // struct Arena {
  //   __impl: ArenaImpl;

  //   constructor(): Arena {
  //     const arena: ArenaImpl;
  //     arena.init();
  //     return Arena<T> { .__impl: arena };
  //   }

  //   allocate(size: u64): RawPtr<none> {
  //     return this.__impl.allocate(size);
  //   }
  // }

  struct Buffer {
    data: RawPtr<none>;
    size: u64;

    constructor(size: u64): Memory.Buffer {
      const a = ctx;
      const buffer = Memory.generalPurposeMalloc(size);
      if !buffer {
        System.panic("Allocation failed");
      }
      return Memory.Buffer {
        .data: buffer,
        .size: size,
      };
    }

    resize(newSize: u64) {
      const newData = Memory.generalPurposeMalloc(newSize);
      if !newData {
        System.panic("Allocation failed");
      }
      Memory.copy(newData, this.data, this.size);
      this.size = newSize;
      this.data = newData;
    }
  }
}

namespace Memory {
  __setupMemoryContext() {
    ctx.mem.alloc = (size: u64): RawPtr<none> => {
      const arena = ctx.mem.globalDefaultArena as RawPtr<Arena>;
      return arena.allocate(size);
    };
    const arena = ctx.mem.globalDefaultArena as RawPtr<Arena>;
    arena.init();
  }
}
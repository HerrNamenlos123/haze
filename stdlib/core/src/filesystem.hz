
namespace ffi {
    // extern C struct hzstd_file_t {};

    extern C noemit enum unscoped hzstd_fs_error_code_t {
        hzstd_fs_error_code_none = 0,

        hzstd_fs_error_code_not_found, // path does not exist
        hzstd_fs_error_code_not_a_file, // exists but not a regular file
        hzstd_fs_error_code_not_a_directory, // exists but not a regular file
        hzstd_fs_error_code_permission_denied,
        hzstd_fs_error_code_already_exists,
        hzstd_fs_error_code_invalid_path, // malformed path, invalid characters, etc.
        hzstd_fs_error_code_name_too_long,
        hzstd_fs_error_code_io_error, // generic read/write failure
        hzstd_fs_error_code_out_of_memory,
    };

    extern C noemit struct hzstd_fs_error_t {
        code: hzstd_fs_error_code_t;
        message: str;
    };

    extern C hzstd_read_file_text(allocator: Allocator, path: str, outputBuffer: hzstd_str_ref_t): inline hzstd_fs_error_t :: final;

    extern C hzstd_write_file_text(allocator: Allocator, path: str, input: str): inline hzstd_fs_error_t :: final;

    extern C hzstd_mkdir_recursive(path: str): inline hzstd_fs_error_t :: final;

    extern C noemit struct hzstd_fs_exists_result_t {
        exists: bool;
        error: inline hzstd_fs_error_t;
    };

    extern C noemit hzstd_fs_exists(path: str): inline hzstd_fs_exists_result_t :: final;

    extern C noemit struct hzstd_fs_copy_options_t {
        overwrite: bool;
        follow_symlinks: bool;
        skip_errors: bool;
    };

    // Copy a file or directory (recursive if needed) to a destination.
    // Automatically creates parent directories. Overwrite, symlink, and error
    // behavior controlled via options.
    extern C noemit hzstd_fs_copy(src: str, dst: str, options: hzstd_fs_copy_options_t): inline hzstd_fs_error_t :: final;

    // Copy a single file to a destination. Parent directories are created
    // automatically. Fails if src is not a file.
    extern C noemit hzstd_fs_copy_file(src: str, dst: str, options: hzstd_fs_copy_options_t): inline hzstd_fs_error_t :: final;

    // Copy a directory recursively to a destination. Parent directories are created
    // automatically. All files and subdirectories are copied according to options.
    extern C noemit hzstd_fs_copy_dir(src: str, dst: str, options: hzstd_fs_copy_options_t): inline hzstd_fs_error_t :: final;

    // Optional: move a file or directory (copy + delete original). Behaves like
    // hzstd_fs_copy.
    extern C noemit hzstd_fs_move(src: str, dst: str, options: hzstd_fs_copy_options_t): inline hzstd_fs_error_t :: final;
}

export namespace fs {
    export enum Error {
        None = 0,

        NotFound,
        NotAFile,
        NotADirectory,
        PermissionDenied,
        AlreadyExists,
        InvalidPath,
        NameTooLong,
        IOError,
        OutOfMemory,
    }

    mapErrorEnum(error: ffi.hzstd_fs_error_code_t): Error {
        if error == ffi.hzstd_fs_error_code_none {
            return Error.None;
        }
        else if error == ffi.hzstd_fs_error_code_not_found {
            return Error.NotFound;
        }
        else if error == ffi.hzstd_fs_error_code_not_a_file {
            return Error.NotAFile;
        }
        else if error == ffi.hzstd_fs_error_code_not_a_directory {
            return Error.NotADirectory;
        }
        else if error == ffi.hzstd_fs_error_code_permission_denied {
            return Error.PermissionDenied;
        }
        else if error == ffi.hzstd_fs_error_code_already_exists {
            return Error.AlreadyExists;
        }
        else if error == ffi.hzstd_fs_error_code_invalid_path {
            return Error.InvalidPath;
        }
        else if error == ffi.hzstd_fs_error_code_name_too_long {
            return Error.NameTooLong;
        }
        else if error == ffi.hzstd_fs_error_code_io_error {
            return Error.IOError;
        }
        else if error == ffi.hzstd_fs_error_code_out_of_memory {
            return Error.OutOfMemory;
        }

        // If this ever triggers, C and Haze enums are out of sync.
        sys.panic("libc haze mappings out of sync");
    }


    export readFile(path: str) {
        return readFile(Alloc.heap(), path);
    }

    export readFile(allocator: Allocator, path: str): Result<str, Error> {
        let output = ffi.hzstd_str_ref_t { data: "" } with allocator;
        let result = ffi.hzstd_read_file_text(allocator, path, output);
        if result.code == ffi.hzstd_fs_error_code_none {
            return Result<str, Error>.Ok(output.data);
        }
        else {
            return Result<str, Error>.Err(mapErrorEnum(result.code));
        }
    }

    export writeFile(path: str, text: str) {
        return writeFile(Alloc.heap(), path, text);
    }

    export writeFile(allocator: Allocator, path: str, text: str): Result<none, Error> {
        let result = ffi.hzstd_write_file_text(allocator, path, text);
        if result.code == ffi.hzstd_fs_error_code_none {
            return Result<none, Error>.Ok(none);
        }
        else {
            return Result<none, Error>.Err(mapErrorEnum(result.code));
        }
    }

    export exists(path: str): Result<bool, Error> {
        let result = ffi.hzstd_fs_exists(path);
        if result.error.code == ffi.hzstd_fs_error_code_none {
            return Result<bool, Error>.Ok(result.exists);
        }
        return Result<bool, Error>.Err(mapErrorEnum(result.error.code));
    }

    export createDirectory(path: str): Result<none, Error> {
        let result = ffi.hzstd_mkdir_recursive(path);
        if result.code == ffi.hzstd_fs_error_code_none {
            return Result<none, Error>.Ok(none);
        }
        return Result<none, Error>.Err(mapErrorEnum(result.code));
    }

    export struct CopyOptions {
        overwrite: bool = false;
        followSymlinks: bool = false;
        skipErrors: bool = false;
    };

    // Copy a file or directory (recursive if needed) to a destination.
    // Automatically creates parent directories. Overwrite, symlink, and error
    // behavior controlled via options.
    export copy(src: str, dst: str, options: CopyOptions): Result<none, Error> {
        let result = ffi.hzstd_fs_copy(src, dst, {
            overwrite: options.overwrite,
            follow_symlinks: options.followSymlinks,
            skip_errors: options.skipErrors,
        });
        if result.code != ffi.hzstd_fs_error_code_none {
            return Result<none, Error>.Err(mapErrorEnum(result.code));
        }
        return Result<none, Error>.Ok(none);
    }

    // Copy a single file to a destination. Parent directories are created
    // automatically. Fails if src is not a file.
    export copyFile(src: str, dst: str, options: CopyOptions): Result<none, Error> {
        let result = ffi.hzstd_fs_copy_file(src, dst, {
            overwrite: options.overwrite,
            follow_symlinks: options.followSymlinks,
            skip_errors: options.skipErrors,
        });
        if result.code != ffi.hzstd_fs_error_code_none {
            return Result<none, Error>.Err(mapErrorEnum(result.code));
        }
        return Result<none, Error>.Ok(none);
    }

    // Copy a directory recursively to a destination. Parent directories are created
    // automatically. All files and subdirectories are copied according to options.
    export copyDirectory(src: str, dst: str, options: CopyOptions): Result<none, Error> {
        let result = ffi.hzstd_fs_copy_dir(src, dst, {
            overwrite: options.overwrite,
            follow_symlinks: options.followSymlinks,
            skip_errors: options.skipErrors,
        });
        if result.code != ffi.hzstd_fs_error_code_none {
            return Result<none, Error>.Err(mapErrorEnum(result.code));
        }
        return Result<none, Error>.Ok(none);
    }

    // Optional: move a file or directory (copy + delete original). Behaves like
    // hzstd_fs_copy.
    export move(src: str, dst: str, options: CopyOptions): Result<none, Error> {
        let result = ffi.hzstd_fs_move(src, dst, {
            overwrite: options.overwrite,
            follow_symlinks: options.followSymlinks,
            skip_errors: options.skipErrors,
        });
        if result.code != ffi.hzstd_fs_error_code_none {
            return Result<none, Error>.Err(mapErrorEnum(result.code));
        }
        return Result<none, Error>.Ok(none);
    }

    // // Static loading
    // let a: str = fs.readText("resources/shader.wgsl");
    // let a: MemoryBuffer = fs.readBinary("font.ttf");
    // let a: DataSource = fs.open("font.ttf");

    // // Pure filesystem watching
    // let a: Reactive<str> = fs.watchText("resources/shader.wgsl", { interval: 0.1 });
    // let a: Reactive<MemoryBuffer> = fs.watchBinary("font.ttf", { interval: 0.1 });
    // let a: Reactive<DataSource> = fs.watchFile("font.ttf", { interval: 0.1 });
}

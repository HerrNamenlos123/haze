
namespace ffi {
    // extern C struct hzstd_file_t {};

    extern C noemit enum unscoped hzstd_fs_error_code_t {
        hzstd_fs_error_code_none = 0,

        hzstd_fs_error_code_not_found, // path does not exist
        hzstd_fs_error_code_not_a_file, // exists but not a regular file
        hzstd_fs_error_code_not_a_directory, // exists but not a regular file
        hzstd_fs_error_code_permission_denied,
        hzstd_fs_error_code_already_exists,
        hzstd_fs_error_code_invalid_path, // malformed path, invalid characters, etc.
        hzstd_fs_error_code_name_too_long,
        hzstd_fs_error_code_io_error, // generic read/write failure
        hzstd_fs_error_code_out_of_memory,
    };

    extern C noemit struct hzstd_fs_error_t {
        code: hzstd_fs_error_code_t;
        message: str;
    };

    extern C hzstd_read_file_text(allocator: Allocator, path: str, outputBuffer: hzstd_str_ref_t): inline hzstd_fs_error_t :: final;

    extern C hzstd_write_file_text(allocator: Allocator, path: str, input: str): inline hzstd_fs_error_t :: final;

    extern C hzstd_mkdir_recursive(path: str): inline hzstd_fs_error_t :: final;

    extern C noemit struct hzstd_fs_exists_result_t {
        exists: bool;
        error: inline hzstd_fs_error_t;
    };

    extern C noemit hzstd_fs_exists(path: str): inline hzstd_fs_exists_result_t :: final;

    extern C noemit struct hzstd_fs_copy_options_t {
        overwrite: bool;
        follow_symlinks: bool;
        skip_errors: bool;
    };

    // Copy a file or directory (recursive if needed) to a destination.
    // Automatically creates parent directories. Overwrite, symlink, and error
    // behavior controlled via options.
    extern C noemit hzstd_fs_copy(src: str, dst: str, options: hzstd_fs_copy_options_t): inline hzstd_fs_error_t :: final;

    // Copy a single file to a destination. Parent directories are created
    // automatically. Fails if src is not a file.
    extern C noemit hzstd_fs_copy_file(src: str, dst: str, options: hzstd_fs_copy_options_t): inline hzstd_fs_error_t :: final;

    // Copy a directory recursively to a destination. Parent directories are created
    // automatically. All files and subdirectories are copied according to options.
    extern C noemit hzstd_fs_copy_dir(src: str, dst: str, options: hzstd_fs_copy_options_t): inline hzstd_fs_error_t :: final;

    // Optional: move a file or directory (copy + delete original). Behaves like
    // hzstd_fs_copy.
    extern C noemit hzstd_fs_move(src: str, dst: str, options: hzstd_fs_copy_options_t): inline hzstd_fs_error_t :: final;

    extern C noemit inline struct hzstd_file_stat_t {
        exists: bool;
        mtime_ns: i64;
        size: i64;
    }

    extern C hzstd_file_stat(path: str): hzstd_file_stat_t :: final;
}

export namespace fs {
    export enum Error {
        None = 0,

        NotFound,
        NotAFile,
        NotADirectory,
        PermissionDenied,
        AlreadyExists,
        InvalidPath,
        NameTooLong,
        IOError,
        OutOfMemory,
    }

    mapErrorEnum(error: ffi.hzstd_fs_error_code_t): Error {
        if error == ffi.hzstd_fs_error_code_none {
            return Error.None;
        }
        else if error == ffi.hzstd_fs_error_code_not_found {
            return Error.NotFound;
        }
        else if error == ffi.hzstd_fs_error_code_not_a_file {
            return Error.NotAFile;
        }
        else if error == ffi.hzstd_fs_error_code_not_a_directory {
            return Error.NotADirectory;
        }
        else if error == ffi.hzstd_fs_error_code_permission_denied {
            return Error.PermissionDenied;
        }
        else if error == ffi.hzstd_fs_error_code_already_exists {
            return Error.AlreadyExists;
        }
        else if error == ffi.hzstd_fs_error_code_invalid_path {
            return Error.InvalidPath;
        }
        else if error == ffi.hzstd_fs_error_code_name_too_long {
            return Error.NameTooLong;
        }
        else if error == ffi.hzstd_fs_error_code_io_error {
            return Error.IOError;
        }
        else if error == ffi.hzstd_fs_error_code_out_of_memory {
            return Error.OutOfMemory;
        }

        // If this ever triggers, C and Haze enums are out of sync.
        sys.panic("libc haze mappings out of sync");
    }


    export readFile(path: str) {
        return readFile(Alloc.heap(), path);
    }

    export readFile(allocator: Allocator, path: str): Result<str, Error> {
        let output = ffi.hzstd_str_ref_t { data: "" } with allocator;
        let result = ffi.hzstd_read_file_text(allocator, path, output);
        if result.code == ffi.hzstd_fs_error_code_none {
            return Result<str, Error>.Ok(output.data);
        }
        else {
            return Result<str, Error>.Err(mapErrorEnum(result.code));
        }
    }

    export writeFile(path: str, text: str) {
        return writeFile(Alloc.heap(), path, text);
    }

    export writeFile(allocator: Allocator, path: str, text: str): Result<none, Error> {
        let result = ffi.hzstd_write_file_text(allocator, path, text);
        if result.code == ffi.hzstd_fs_error_code_none {
            return Result<none, Error>.Ok(none);
        }
        else {
            return Result<none, Error>.Err(mapErrorEnum(result.code));
        }
    }

    export exists(path: str): Result<bool, Error> {
        let result = ffi.hzstd_fs_exists(path);
        if result.error.code == ffi.hzstd_fs_error_code_none {
            return Result<bool, Error>.Ok(result.exists);
        }
        return Result<bool, Error>.Err(mapErrorEnum(result.error.code));
    }

    export createDirectory(path: str): Result<none, Error> {
        let result = ffi.hzstd_mkdir_recursive(path);
        if result.code == ffi.hzstd_fs_error_code_none {
            return Result<none, Error>.Ok(none);
        }
        return Result<none, Error>.Err(mapErrorEnum(result.code));
    }

    export struct CopyOptions {
        overwrite: bool = false;
        followSymlinks: bool = false;
        skipErrors: bool = false;
    };

    // Copy a file or directory (recursive if needed) to a destination.
    // Automatically creates parent directories. Overwrite, symlink, and error
    // behavior controlled via options.
    export copy(src: str, dst: str, options: CopyOptions): Result<none, Error> {
        let result = ffi.hzstd_fs_copy(src, dst, {
            overwrite: options.overwrite,
            follow_symlinks: options.followSymlinks,
            skip_errors: options.skipErrors,
        });
        if result.code != ffi.hzstd_fs_error_code_none {
            return Result<none, Error>.Err(mapErrorEnum(result.code));
        }
        return Result<none, Error>.Ok(none);
    }

    // Copy a single file to a destination. Parent directories are created
    // automatically. Fails if src is not a file.
    export copyFile(src: str, dst: str, options: CopyOptions): Result<none, Error> {
        let result = ffi.hzstd_fs_copy_file(src, dst, {
            overwrite: options.overwrite,
            follow_symlinks: options.followSymlinks,
            skip_errors: options.skipErrors,
        });
        if result.code != ffi.hzstd_fs_error_code_none {
            return Result<none, Error>.Err(mapErrorEnum(result.code));
        }
        return Result<none, Error>.Ok(none);
    }

    // Copy a directory recursively to a destination. Parent directories are created
    // automatically. All files and subdirectories are copied according to options.
    export copyDirectory(src: str, dst: str, options: CopyOptions): Result<none, Error> {
        let result = ffi.hzstd_fs_copy_dir(src, dst, {
            overwrite: options.overwrite,
            follow_symlinks: options.followSymlinks,
            skip_errors: options.skipErrors,
        });
        if result.code != ffi.hzstd_fs_error_code_none {
            return Result<none, Error>.Err(mapErrorEnum(result.code));
        }
        return Result<none, Error>.Ok(none);
    }

    // Optional: move a file or directory (copy + delete original). Behaves like
    // hzstd_fs_copy.
    export move(src: str, dst: str, options: CopyOptions): Result<none, Error> {
        let result = ffi.hzstd_fs_move(src, dst, {
            overwrite: options.overwrite,
            follow_symlinks: options.followSymlinks,
            skip_errors: options.skipErrors,
        });
        if result.code != ffi.hzstd_fs_error_code_none {
            return Result<none, Error>.Err(mapErrorEnum(result.code));
        }
        return Result<none, Error>.Ok(none);
    }

    export struct FileState {
        mtime: int;   // or platform timestamp type
        size: int;    // optional but useful
    }

    export statFile(path: str): FileState | none {
        let result = ffi.hzstd_file_stat(path);
        if !result.exists {
            return none;
        }

        return FileState {
            mtime: result.mtime_ns,
            size: result.size,
        };
    }

    export enum WatchStrategy {
        ModificationDate,
        DiffContent,
    }

    export struct WatchConfig {
        interval: real = 0.1;
        immediate: bool = true;
        strategy: WatchStrategy = WatchStrategy.ModificationDate;
    }

    export struct FileChangeEvent {
        path: str;
        kind: FileChangeKind;
    }

    export enum FileChangeKind {
        Modified,
        Created,
        Deleted,
    }

    export struct WatchHandle {
        handle: int;
    }

    struct Watcher {
        id: int;
        path: str;
        interval: real;
        nextPollTime: real;
        lastState?: FileState;
        lastContent?: str;
        callback: (event: FileChangeEvent) => void;
        active: bool;
        strategy: WatchStrategy;
    }

    struct GlobalFilesystemContext {
        watchers: []Watcher;
        nextId: int;
        inPoll: bool;
    }

    // Global context that is lazily initialized on first use
    extern C let _globalFilesystemContext: mut GlobalFilesystemContext | none = none;

    // Lazily initialize the global filesystem context on first use
    _getFilesystemContext(): mut GlobalFilesystemContext {
        if _globalFilesystemContext {
            return _globalFilesystemContext;
        }
        
        // If we reach here, it was none, so initialize it
        _globalFilesystemContext = GlobalFilesystemContext {
            watchers: [],
            nextId: 1,
            inPoll: false,
        };
        
        assert(_globalFilesystemContext);
        return _globalFilesystemContext;
    }

    export watch(
        path: str,
        onChange: (event: FileChangeEvent) => void,
        config?: WatchConfig,
    ): WatchHandle {
        let state = statFile(path);
        let content: str | none = none;

        if !config {
            config = WatchConfig {};
        }
        assert(config);

        if config.strategy == WatchStrategy.DiffContent {
            if state {
                let fileResult = readFile(path);
                if fileResult {
                    content = fileResult;
                }
            }
        }

        let ctx = _getFilesystemContext();
        let w = Watcher {
            id: ctx.nextId++,
            path: path,
            interval: config.interval,
            nextPollTime: time.now() + config.interval,
            lastState: state,
            lastContent: content,
            callback: onChange,
            active: true,
            strategy: config.strategy,
        };
        ctx.watchers.push(w);

        if config.immediate {
            onChange({
                path: path,
                kind: state ? FileChangeKind.Created : FileChangeKind.Deleted
            });
        }

        return WatchHandle { handle: w.id };
    }

    export unwatch(handle: WatchHandle) {
        let ctx = _getFilesystemContext();
        for w in ctx.watchers {
            if w.id == handle.handle {
                w.active = false;
                return;
            }
        }
    }

    diff(old?: FileState, new?: FileState): FileChangeEvent | none {
        if !old && new {
            return FileChangeEvent {
                path: "", // filled by caller
                kind: FileChangeKind.Created,
            };
        }

        if old && !new {
            return FileChangeEvent {
                path: "",
                kind: FileChangeKind.Deleted,
            };
        }

        if old && new {
            if old.mtime != new.mtime || old.size != new.size {
                return FileChangeEvent {
                    path: "",
                    kind: FileChangeKind.Modified,
                };
            }
        }

        return none;
    }

    // This function will disappear in the future in favor of a global coroutine event loop
    export pollEvents() {
        let ctx = _getFilesystemContext();
        if ctx.inPoll { return; }
        ctx.inPoll = true;

        if !_globalFilesystemContext {
            ctx.inPoll = false;
            return;
        }

        let t = time.now();
        for w in ctx.watchers {
            if w.active {
                if t >= w.nextPollTime {
                    while w.nextPollTime <= t {
                        w.nextPollTime += w.interval;
                    }

                    if w.strategy == WatchStrategy.ModificationDate {
                        let newState = statFile(w.path);
                        let event = diff(w.lastState, newState);
                        if event {
                            event.path = w.path;
                            w.lastState = newState;
                            w.callback(event);
                        }
                    } else if w.strategy == WatchStrategy.DiffContent {
                        let newState = statFile(w.path);
                        let lifecycle = diff(w.lastState, newState);

                        if lifecycle && lifecycle.kind != FileChangeKind.Modified {
                            lifecycle.path = w.path;
                            w.lastState = newState;
                            w.lastContent = none;
                            w.callback(lifecycle);
                        }

                        if lifecycle && lifecycle.kind == FileChangeKind.Modified {
                            let fileResult = readFile(w.path);
                            if fileResult {
                                let newContent = fileResult;

                                if !w.lastContent || (w.lastContent && w.lastContent != newContent) {
                                    w.lastContent = newContent;
                                    w.lastState = newState;
                                    w.callback({
                                        path: w.path,
                                        kind: FileChangeKind.Modified
                                    });
                                }
                            }
                            else {
                                // treat as deletion race
                                w.lastState = none;
                                w.lastContent = none;
                                w.callback({
                                    path: w.path,
                                    kind: FileChangeKind.Deleted
                                });
                            }
                        }
                    }
                }
            }
        }

        // TODO: Filtering/deleting is not possible yet
        // ctx.watchers = ctx.watchers.filter(w => w.active);

        ctx.inPoll = false;
    }

    // // Static loading
    // let a: str = fs.readText("resources/shader.wgsl");
    // let a: MemoryBuffer = fs.readBinary("font.ttf");
    // let a: DataSource = fs.open("font.ttf");

    // // Pure filesystem watching
    // let a: Reactive<str> = fs.watchText("resources/shader.wgsl", { interval: 0.1 });
    // let a: Reactive<MemoryBuffer> = fs.watchBinary("font.ttf", { interval: 0.1 });
    // let a: Reactive<DataSource> = fs.watchFile("font.ttf", { interval: 0.1 });
}

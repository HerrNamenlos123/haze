
namespace ffi {
    extern C noemit struct hzstd_regex_blob_t {};
    extern C hzstd_regex_runtime_compile(pattern: str, flags: str, error_message: ffi.hzstd_str_ref_t): hzstd_regex_blob_t :: final;

    extern C noemit struct hzstd_regex_span_t {
        start: usize;
        end: usize;
    };

    extern C noemit struct hzstd_regex_group_t {
        span: inline hzstd_regex_span_t;
        text: str;
        present: bool;
    };

    extern C noemit struct hzstd_regex_find_match_t {
        span: inline hzstd_regex_span_t;
        text: str;
        groups: []inline hzstd_regex_group_t;
    };

    extern C noemit struct hzstd_regex_find_one_result_t {
        found: bool;
        // 'match' may only be accessed if 'found' is true
        match: inline hzstd_regex_find_match_t;
    };

    extern C noemit hzstd_regex_match(regex: Regex, text: str): bool :: final;
    extern C noemit hzstd_regex_find(allocator: Allocator, regex: Regex, text: str): inline hzstd_regex_find_one_result_t :: final;
    extern C noemit hzstd_regex_find_all(allocator: Allocator, regex: Regex, text: str): [](inline hzstd_regex_find_match_t) :: final;
    extern C noemit hzstd_regex_replace(regex: Regex, text: str, replacement: str): str :: final;
}

namespace regex {
    export struct Span {
        start: int;
        end: int;
    }

    export struct Group {
        span: Span;
        text: str;
        present: bool;
    }

    export struct Match {
        span: Span;
        text: str;
        groups: []Group;
    }

    export runtime(pattern: str, flags?: str): Result<Regex, str> {
        do unsafe {
            let realFlags = "";
            if flags { // TODO: We have to go this workaround, once supported the flag should just be a default param.
                realFlags = flags;
            }

            let errorMessage = ffi.hzstd_str_ref_t {};
            let resultBlob = ffi.hzstd_regex_runtime_compile(pattern, realFlags, errorMessage);

            let isError = false;
            __c__("isError = resultBlob == NULL;");
            if isError {
                return Result<Regex, str>.Err(errorMessage.data);
            }
            let resultRegex: Regex = uninitialized;
            __c__("resultRegex.blob = resultBlob;");
            return Result<Regex, str>.Ok(resultRegex);
        };
    }

    export match(regex: Regex, text: str): bool {
        return ffi.hzstd_regex_match(regex, text);
    }

    export find(r: Regex, text: str): Match | none {
        return find(Alloc.heap(), r, text);
    }

    export find(allocator: Allocator, r: Regex, text: str): Match | none {
        let result = ffi.hzstd_regex_find(allocator, r, text);
        if !result.found {
            return none;
        }

        let start = result.match.span.start;
        let end = result.match.span.end;
        if start > int.max {
            sys.panic(f"Integer overflow in regex_find result start index: {start} > {int.max}");
        }
        if end > int.max {
            sys.panic(f"Integer overflow in regex_find result end index: {end} > {int.max}");
        }

        let groups: []Group = [];
        for (let i = 0; i < result.match.groups.length; i++) {
            let s = result.match.groups[i].span.start;
            let e = result.match.groups[i].span.end;
            assert(s <= int.max, f"Integer overflow in regex_find result start index: {start} > {int.max}");
            assert(e <= int.max, f"Integer overflow in regex_find result end index: {start} > {int.max}");
            groups.push({
                span: {
                    start: s,
                    end: e,
                },
                text: result.match.groups[i].text,
                present: result.match.groups[i].present,
            });
        }

        return Match {
            span: {
                start: start,
                end: end,
            },
            text: result.match.text,
            groups: groups,
        };
    }

    export findAll(r: Regex, text: str) {
        return findAll(Alloc.heap(), r, text);
    }

    export findAll(allocator: Allocator, r: Regex, text: str): []Match {
        let result = ffi.hzstd_regex_find_all(allocator, r, text);
        let matches: []Match = [];
        for (let i = 0; i < result.length; i++) {
            let start = result[i].span.start;
            let end = result[i].span.end;
            if start > int.max {
                sys.panic(f"Integer overflow in regex_find result start index: {start} > {int.max}");
            }
            if end > int.max {
                sys.panic(f"Integer overflow in regex_find result end index: {end} > {int.max}");
            }

            let groups: []Group = [];
            for (let j = 0; j < result[i].groups.length; j++) {
                let s = result[i].groups[j].span.start;
                let e = result[i].groups[j].span.end;
                assert(s <= int.max, f"Integer overflow in regex_find result start index: {start} > {int.max}");
                assert(e <= int.max, f"Integer overflow in regex_find result end index: {start} > {int.max}");
                groups.push({
                    span: {
                        start: s,
                        end: e,
                    },
                    text: result[i].groups[j].text,
                    present: result[i].groups[j].present,
                });
            }

            matches.push({
                span: {
                    start: start,
                    end: end,
                },
                text: result[i].text,
                groups: groups,
            });
        }
        return matches;
    }

    export replace(r: Regex, text: str, replacement: str): str {
        return ffi.hzstd_regex_replace(r, text, replacement);
    }
}
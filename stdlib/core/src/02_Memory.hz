
extern "C" noemit calloc(num: u64, size: u64): none*;
extern "C" noemit realloc(ptr: none*, newSize: u64): none*;
extern "C" noemit free(ptr: none*);
extern "C" noemit memcpy(to: none*, from: none*, length: u64): none*;

export struct StackArray<T, Size> {
  length: u64;
  data: __C_Array<i32, Size>;
}

struct Array<T> {
  constructor(arena: Arena): Array<T> {
    return Array<T> {};
  }

  set() {

  }
}

foo() {
  const arena = Arena();
  // defer arena.free();

  const array = Array<i32>(arena);
  array.set();
}

// struct Node<T> {
//   value: T;
//   next: Node<T>;
// }

struct Arena {

  constructor(): Arena {
    // const arena: ArenaImpl;
    // arena.init();
    return Arena {};
  }

  // allocate(size: u64): none* {
  //   return this.__impl.allocate(size);
  // }
}

namespace Memory {
  // const DEFAULT_ARENA_SIZE = 16 * 1024 * 1024;

//   getDefaultArenaSize(): u64 => {
//     return (16 * 1024 * 1024) as u64;
//   }

//   export generalPurposeMalloc(size: u64): none* => {
//     return calloc(1 as u64, size);
//   }

//   export generalPurposeFree(ptr: none*) => {
//     free(ptr);
//   }

//   export copy(to: none*, from: none*, length: u64) => {
//     memcpy(to, from, length);
//   }

  export struct ArenaChunk {
    nextChunk: ArenaChunk*;
    // allocated: u64;
    // capacity: u64;
    // dataFirstByte: u8;

    // canAllocate(size: u64): boolean {
    //   return this.allocated + size <= this.capacity;
    // }

    // allocate(size: u64): none* {
    //   if this.allocated + size > this.capacity {
    //     System.panic("ArenaChunk was instructed to allocate, but it is too small");
    //   }
    //   const ptr = 0 as none*;
    //   __c__("ptr = &(this->dataFirstByte) + this->allocated");
    //   this.allocated += size;
    //   return ptr;
    // }
  }

  export struct Arena {
    firstChunk: ArenaChunk*;

    // init(): none {
    //   if this.firstChunk {
    //     System.panic("Arena is already initialized");
    //   }
    //   const chunkSize = sizeof<none*> + 2 * sizeof<u64> + Memory.getDefaultArenaSize();
    //   this.firstChunk = Memory.generalPurposeMalloc(chunkSize) as ArenaChunk*;
    //   this.firstChunk.capacity = Memory.getDefaultArenaSize();
    // }

    // allocate(size: u64): none* {
    //   let chunk = this.firstChunk;
    //   while chunk.nextChunk {
    //     chunk = chunk.nextChunk;
    //   }
    //   if not chunk.canAllocate(size) {
    //     const chunkSize = sizeof<none*> + 2 * sizeof<u64> + Math.maxu64(Memory.getDefaultArenaSize(), size);
    //     chunk.nextChunk = Memory.generalPurposeMalloc(chunkSize) as ArenaChunk*;
    //     if not chunk.nextChunk {
    //       System.panic("Allocation failed while enlarging arena");
    //     }
    //     chunk.nextChunk.capacity = Math.maxu64(Memory.getDefaultArenaSize(), size);
    //     ctx.log.warn("Arena was enlarged. Consider creating a bigger, short-lived arena for memory-heavy calculations.");
    //     chunk = chunk.nextChunk;
    //     if not chunk.canAllocate(size) {
    //       Console.print("New chunk: Allocated=%lu, capacity=%lu, requested=%lu\n", chunk.allocated, chunk.capacity, size);
    //       System.panic("Allocation failed: Requested size is too large to fit in Arena chunk (Internal error)");
    //     }
    //   }
    //   return chunk.allocate(size);
    // }

    // cleanup() {
    //   let chunk = this.firstChunk;
    //   while chunk {
    //     const next = chunk.nextChunk;
    //     Memory.generalPurposeFree(chunk);
    //     chunk = next;
    //   }
    //   this.firstChunk = 0 as RawPtr<ArenaChunk>;
    // }
  }

  // struct Arena {
  //   __impl: ArenaImpl;

  //   constructor(): Arena {
  //     const arena: ArenaImpl;
  //     arena.init();
  //     return Arena<T> { .__impl: arena };
  //   }

  //   allocate(size: u64): none* {
  //     return this.__impl.allocate(size);
  //   }
  // }

//   export struct Buffer {
//     data: none*;
//     size: u64;

//     constructor(size: u64): Memory.Buffer {
//       return Memory.Buffer {
//         .data = ctx.mem.alloc(size),
//         .size = size,
//       };
//     }

//     resize(newSize: u64) {
//       const newData = ctx.mem.alloc(newSize);
//       Memory.copy(newData, this.data, this.size);
//       this.size = newSize;
//       this.data = newData;
//     }
//   }

//   __setupMemoryContext() {
//     ctx.mem.alloc = (size: u64): none* => {
//       const arena = ctx.mem.globalDefaultArena as RawPtr<Arena>;
//       return arena.allocate(size);
//     };
//     const arena = ctx.mem.globalDefaultArena as RawPtr<Arena>;
//     arena.init();
//   }
}
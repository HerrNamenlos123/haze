
export extern C noemit struct hzstd_arena_t {};

export extern C noemit hzstd_arena_create(): hzstd_arena_t :: final;
export extern C noemit hzstd_arena_cleanup_and_free(arena: hzstd_arena_t): void :: final;

export extern C noemit hzstd_arena_allocate(arena: hzstd_arena_t, size: usize, alignment: usize): cptr :: final;

export extern C noemit hzstd_arena_create_and_attach_subarena(arena: hzstd_arena_t): hzstd_arena_t :: final;
export extern C noemit hzstd_attach_subarena(arena: hzstd_arena_t, subarena: hzstd_arena_t): void :: final;
export extern C noemit hzstd_detach_subarena(arena: hzstd_arena_t): void :: final;

export extern C noemit hzstd_arena_register_cleanup_action(arena: hzstd_arena_t, action: (actiondata: void) => cptr, actiondata: cptr): usize :: final;
export extern C noemit hzstd_arena_deregister_cleanup_action(arena: hzstd_arena_t, actionId: usize): void :: final;

// const DEFAULT_CHUNK_SIZE = 1024;

export struct Arena {
    arenaImpl: hzstd_arena_t;

    constructor() {
        return Arena {
            arenaImpl: hzstd_arena_create(),
        };
    }
    
    alloc<T>(value: T) {
        do unsafe {
            const ptr = hzstd_arena_allocate<T>(this.arenaImpl, sizeof(T), alignof(T));
            ptr := value;
            return ptr as T;
        }
    }

    free() {
        hzstd_arena_cleanup_and_free(this.arenaImpl);
    }
}

export opaque struct MemoryBuffer {
    // TODO: Introduce a way to prevent a struct from being made using a literal and only using its constructor instead.
    length: int;
    __data: u8; // This is the first byte of the data, the remaining data comes after it but Haze can't express it.

    constructor(length: int) {
        do unsafe {
            let arena = fn.returnArena;

            let a = MemoryBuffer {
                length: 0,
                __data: 0,
            };

            let buffer: unique mut MemoryBuffer = uninitialized;
            __c__("buffer = hzstd_arena_allocate(arena->arenaImpl, sizeof(hzstd_int_t) + length, alignof(hzstd_int_t));");
            // We trust the arena that everything is zeroed
            buffer.length = length;

            return buffer;
        }
    }

    operator[](index: int): ByteRef {
        if (index < 0 || index >= this.length) {
            sys.panic("Out of bounds access in MemoryBuffer");
        }

        return {
            buffer: this,
            index: index,
        };
    }

    getAt(index: int): u8 {
        if (index < 0 || index >= this.length) {
            sys.panic("Out of bounds access in MemoryBuffer");
        }

        let result: u8 = 0;
        __c__("result = (&this->__data)[index];");
        return result;
    }

    setAt(index: int, value: u8) {
        if (index < 0 || index >= this.length) {
            sys.panic("Out of bounds access in MemoryBuffer");
        }

        __c__("(&this->__data)[index] = value;");
    }

    mut write(data: str, index: int) {
        if (index < 0 || index + data.length - 1 >= this.length) {
            sys.panic("Out of bounds access in MemoryBuffer");
        }

        __c__("memcpy(&this->__data + index, data.data, data.length);");
    }

    const toString(): str {
        let result = "";
        if (this.length > 0) {
            __c__("result = HZSTD_STRING((const char*)&this->__data, this->length);");
        }
        return result;
    }

    struct ByteRef {
        buffer: MemoryBuffer;
        index: int;

        get(): u8 {
            return this.buffer.getAt(this.index);
        }

        operator:=(value: u8) {
            this.buffer.setAt(this.index, value);
        }
    }
}
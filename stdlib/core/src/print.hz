
__c__("#include <stdio.h>");

namespace ffi {
    export extern C noemit printf(fmt: ccstr, ...) :: final;
}

namespace fmt {
    export struct FormatArgs {
        formatSpecifier: str = "";
    }

    export opaque struct StringWriter {
        buffer: mut MemoryBuffer | none;
        written: int = 0;

        constructor(buffer?: mut MemoryBuffer) {
            return StringWriter {
                buffer: buffer,
            };
        }

        mut write(value: str) {
            let buffer = this.buffer;
            if buffer {
                buffer.write(this.written, value);
            }
            this.written += value.length;
        }

        commit() {
            const buffer = this.buffer;
            if buffer {
                buffer.commit();
            }
        }

        string() {
            const buffer = this.buffer;
            if (buffer) {
                return buffer.string();
            }
            else {
                return "";
            }
        }
    }

    export format(values: ...) {
        let reader = StringWriter(none);
        for comptime value, i in values {
            format_to(reader, value, {});
        }
        let writer = StringWriter(MemoryBuffer(reader.written));
        for comptime value, i in values {
            format_to(writer, value, {});
        }
        writer.commit();
        return writer.string();
    }

    // export foo(allocator: Allocator, values: ...) {
    //     for comptime value, i in values {
    //         let a = value;
    //     }
    // }

    export formatWithAllocator(allocator: Allocator, values: ...) {
        let reader = StringWriter(none);
        for comptime value, i in values {
            format_to(reader, value, {});
        }
        let writer = StringWriter(MemoryBuffer(allocator, reader.written));
        for comptime value, i in values {
            format_to(writer, value, {});
        }
        writer.commit();
        return writer.toString();
    }


    export digitToStr(digit: int): str {
        assert(digit >= 0 && digit <= 9);
        let result: str = "";
        __c__("static const char* digits[] = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\" };");
        __c__("result = HZSTD_STRING(digits[digit], 1);");
        return result;
    }

    export print(args: ...) {
        for comptime arg in args {
            type Arg = typeof(arg);

            // If this is the same, then Arg is reactive, because reactives cannot be nested
            // and Reactive<Reactive<T>> is by definition the same as Reactive<T>
            if comptime type<IsReactive<Arg>> {
                // print();
                // static_assert(false, "TRUE");
                return;
            }

            if comptime typeof(arg) is int || typeof(arg) is mut int {
                const value = arg;
                // ffi.printf("%lld", arg);
                __c__("printf(\"%\"PRId64, value);");
            }
            else if typeof(arg) is cstr || typeof(arg) is ccstr {
                const s = arg;
                __c__("printf(\"%s\", s);");
                // ffi.printf("%s", arg);
            }
            else if typeof(arg) is str {
                const s = arg;
                __c__("fwrite(s.data, 1, s.length, stdout);");
                // ffi.printf("%s", arg);
            }
            else if typeof(arg) is str {
                const s = arg;
                __c__("fwrite(s.data, 1, s.length, stdout);");
                // ffi.printf("%s", arg);
            }
            else if typeof(arg) is bool {
                if arg {
                    ffi.printf("true");
                }
                else {
                    ffi.printf("false");
                }
            }
            else if typeof(arg) is usize {
                ffi.printf("%zu", arg);
            }
            else if typeof(arg) is real || typeof(arg) is mut real {
                ffi.printf("%f", arg);
            }
            else if typeof(arg) is u8 || typeof(arg) is u16 || typeof(arg) is u32 {
                const value = arg;
                __c__("printf(\"%\"PRIu8, value);");
            }
            else if typeof(arg) is u64 {
                const value = arg;
                __c__("printf(\"%\"PRIu64, value);");
            }
            else if typeof(arg) is i8 || typeof(arg) is i16 || typeof(arg) is i32 {
                const value = arg;
                __c__("printf(\"%\"PRId8, value);");
            }
            else if typeof(arg) is i64 {
                const value = arg;
                __c__("printf(\"%\"PRId64, value);");
            }
            else if typeof(arg) is Vec2 || typeof(arg) is Vec2 {
                ffi.printf("(%f, %f)", arg.x, arg.y);
            }
            else if typeof(arg) is Vec3 || typeof(arg) is Vec3 {
                ffi.printf("(%f, %f, %f)", arg.x, arg.y, arg.z);
            }
            else if typeof(arg) is Vec4 || typeof(arg) is Vec4 {
                ffi.printf("(%f, %f, %f, %f)", arg.x, arg.y, arg.z, arg.w);
            }
            else if typeof(arg) is fs.Error {
                ffi.printf("%d", arg);
            }
            else if typeof(arg) is null {
                ffi.printf("null");
            }
            else if typeof(arg) is none {
                ffi.printf("none");
            }
            else if typeof(arg) is Vec2f || typeof(arg) is mut _Vec2<f32> {
                let s = format(arg);
                __c__("fwrite(s.data, 1, s.length, stdout);");
            }
            else {
                static_assert(false, "Type '" + typeof(arg).name + "' is not supported in fmt.print");
            }
        }
    }

    export println(args: ...) {
        for comptime arg, i in args {
            print(arg);
            if comptime i != args.length - 1 {
                print(" ");
            }
        }
        print("\n");
    }

    export format_to(writer: mut StringWriter, value: i64, args: FormatArgs) {
        let v = value;
        if v < 0 {
            writer.write("-");
            if v == -9223372036854775808 {
                writer.write("9223372036854775808");
                return;
            }
            v = -v;
        }

        // Find highest divisor
        let div: i64 = 1;
        while v / div >= 10 as i64 {
            div *= 10;
        }

        while div > 0 as i64 {
            let digit = v / div;
            writer.write(digitToStr(digit));
            v %= div;
            div /= 10;
        }
    }

    export format_to(writer: mut StringWriter, value: u64, args: FormatArgs) {
        let v = value;

        // Find highest divisor
        let div: u64 = 1;
        while v / div >= 10 {
            div *= 10;
        }

        while div > 0 {
            let digit = v / div;
            assert(digit >= 0 && digit <= 9);
            writer.write(digitToStr(digit));
            v %= div;
            div /= 10;
        }
    }

    export format_to(writer: mut StringWriter, value: i8, args: FormatArgs) {
        format_to(writer, value as i64, args);
    }

    export format_to(writer: mut StringWriter, value: i16, args: FormatArgs) {
        format_to(writer, value as i64, args);
    }

    export format_to(writer: mut StringWriter, value: i32, args: FormatArgs) {
        format_to(writer, value as i64, args);
    }

    export format_to(writer: mut StringWriter, value: int, args: FormatArgs) {
        format_to(writer, value as i64, args);
    }

    export format_to(writer: mut StringWriter, value: str, args: FormatArgs) {
        writer.write(value);
    }
    
    export format_to(writer: mut StringWriter, value: u8, args: FormatArgs) {
        format_to(writer, value as u64, args);
    }

    export format_to(writer: mut StringWriter, value: u16, args: FormatArgs) {
        format_to(writer, value as u64, args);
    }

    export format_to(writer: mut StringWriter, value: u32, args: FormatArgs) {
        format_to(writer, value as u64, args);
    }

    export format_to(writer: mut StringWriter, value: usize, args: FormatArgs) {
        format_to(writer, value as u64, args);
    }

    export format_to(writer: mut StringWriter, value: f32, args: FormatArgs) {
        let n = 0;
        let string = "";
        __c__("""
char buf[64];
n = snprintf(buf, sizeof(buf), "%.9g", value);
string = HZSTD_STRING_FROM_CSTR(buf);
        """);
        if n > 0 && n < 64 {
            writer.write(string);
        }
    }

    export format_to(writer: mut StringWriter, value: f64, args: FormatArgs) {
        let n = 0;
        let string = "";
        __c__("""
char buf[64];
n = snprintf(buf, sizeof(buf), "%.17g", value);
string = HZSTD_STRING_FROM_CSTR(buf);
        """);
        if n > 0 && n < 64 {
            writer.write(string);
        }
    }

    export format_to(writer: mut StringWriter, value: real, args: FormatArgs) {
        format_to(writer, value as f64, args);
    }

    export format_to(writer: mut StringWriter, value: fs.Error, args: FormatArgs) {
        let num = 0;
        __c__("num = value;");
        format_to(writer, num, args);
    }

    export format_to(writer: mut StringWriter, value: none, args: FormatArgs) {
        format_to(writer, "none", args);
    }

    export format_to(writer: mut StringWriter, value: null, args: FormatArgs) {
        format_to(writer, "null", args);
    }

    export format_to(writer: mut StringWriter, value: Vec2f, args: FormatArgs) {
        format_to(writer, "(", args);
        format_to(writer, value.x, args);
        format_to(writer, ", ", args);
        format_to(writer, value.y, args);
        format_to(writer, ")", args);
    }

    export format_to(writer: mut StringWriter, value: mut _Vec2<f32>, args: FormatArgs) {
        format_to(writer, value as Vec2f, args);
    }
}
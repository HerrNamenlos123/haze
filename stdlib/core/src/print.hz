
__c__("#include <stdio.h>");

namespace ffi {
    export extern C noemit printf(fmt: ccstr, ...) :: final;
}

namespace fmt {
    export struct FormatArgs {
        formatSpecifier: str = "";
    }

    export opaque struct StringWriter {
        buffer: mut ByteBuffer | none;
        written: int = 0;

        constructor(buffer?: mut ByteBuffer) {
            return StringWriter {
                buffer: buffer,
            };
        }

        mut write(value: str) {
            let buffer = this.buffer;
            if buffer {
                buffer.write(this.written, value);
            }
            this.written += value.length;
        }

        commit() {
            const buffer = this.buffer;
            if buffer {
                buffer.commit();
            }
        }

        string() {
            const buffer = this.buffer;
            if (buffer) {
                return buffer.string();
            }
            else {
                return "";
            }
        }
    }

    export format(values: ...) {
        let reader = StringWriter(none);
        for comptime value, i in values {
            format_to(reader, value, {});
        }
        let writer = StringWriter(ByteBuffer(reader.written));
        for comptime value, i in values {
            format_to(writer, value, {});
        }
        writer.commit();
        return writer.string();
    }

    // export foo(allocator: Allocator, values: ...) {
    //     for comptime value, i in values {
    //         let a = value;
    //     }
    // }

    export formatWithAllocator(allocator: Allocator, values: ...) {
        let reader = StringWriter(none);
        for comptime value, i in values {
            format_to(reader, value, {});
        }
        let writer = StringWriter(ByteBuffer(allocator, reader.written));
        for comptime value, i in values {
            format_to(writer, value, {});
        }
        writer.commit();
        return writer.toString();
    }


    export digitToStr(digit: int): str {
        assert(digit >= 0 && digit <= 9);
        let result: str = "";
        __c__("static const char* digits[] = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\" };");
        __c__("result = HZSTD_STRING(digits[digit], 1);");
        return result;
    }

    export printFragment<T>(value: T) {
        if comptime type<IsReactive<T>> {
            printFragment<ReactiveInner<T>>(value);
        }
        else {
            if comptime T is int || T is mut int {
                __c__("printf(\"%\"PRId64, value);");
            }
            else if T is cstr || T is ccstr {
                __c__("printf(\"%s\", value);");
            }
            else if T is str {
                __c__("fwrite(value.data, 1, value.length, stdout);");
            }
            else if T is str {
                __c__("fwrite(value.data, 1, value.length, stdout);");
            }
            else if T is bool {
                if value {
                    ffi.printf("true");
                }
                else {
                    ffi.printf("false");
                }
            }
            else if T is usize {
                ffi.printf("%zu", value);
            }
            else if T is real || T is mut real {
                ffi.printf("%f", value);
            }
            else if T is u8 || T is u16 || T is u32 {
                __c__("printf(\"%\"PRIu8, value);");
            }
            else if T is u64 {
                __c__("printf(\"%\"PRIu64, value);");
            }
            else if T is i8 || T is i16 || T is i32 {
                __c__("printf(\"%\"PRId8, value);");
            }
            else if T is i64 {
                __c__("printf(\"%\"PRId64, value);");
            }
            else if T is Vec2 || T is Vec2 {
                ffi.printf("(%f, %f)", value.x, value.y);
            }
            else if T is Vec3 || T is Vec3 {
                ffi.printf("(%f, %f, %f)", value.x, value.y, value.z);
            }
            else if T is Vec4 || T is Vec4 {
                ffi.printf("(%f, %f, %f, %f)", value.x, value.y, value.z, value.w);
            }
            else if T is fs.Error {
                ffi.printf("%d", value);
            }
            else if T is null {
                ffi.printf("null");
            }
            else if T is none {
                ffi.printf("none");
            }
            else if T is Vec2f || T is mut _Vec2<f32> {
                let s = format(value);
                __c__("fwrite(s.data, 1, s.length, stdout);");
            }
            else {
                static_assert(false, "Type '" + T.name + "' is not supported in fmt.print");
            }
        }
    }

    export print(args: ...) {
        for comptime arg, i in args {
            printFragment<typeof(arg)>(arg);
            if comptime i != args.length - 1 {
                printFragment<str>(" ");
            }
        }
    }

    export println(args: ...) {
        for comptime arg, i in args {
            printFragment<typeof(arg)>(arg);
            if comptime i != args.length - 1 {
                printFragment<str>(" ");
            }
        }
        printFragment<str>("\n");
    }

    export format_to(writer: mut StringWriter, value: i64, args: FormatArgs) {
        let v = value;
        if v < 0 {
            writer.write("-");
            if v == -9223372036854775808 {
                writer.write("9223372036854775808");
                return;
            }
            v = -v;
        }

        // Find highest divisor
        let div: i64 = 1;
        while v / div >= 10 as i64 {
            div *= 10 as i64;
        }

        while div > 0 as i64 {
            let digit = v / div;
            writer.write(digitToStr(digit));
            v %= div;
            div /= 10 as i64;
        }
    }

    export format_to(writer: mut StringWriter, value: u64, args: FormatArgs) {
        let v = value;

        // Find highest divisor
        let div: u64 = 1;
        while v / div >= 10 {
            div *= 10;
        }

        while div > 0 {
            let digit = v / div;
            assert(digit >= 0 && digit <= 9);
            writer.write(digitToStr(digit));
            v %= div;
            div /= 10;
        }
    }

    export format_to(writer: mut StringWriter, value: i8, args: FormatArgs) {
        format_to(writer, value as i64, args);
    }

    export format_to(writer: mut StringWriter, value: i16, args: FormatArgs) {
        format_to(writer, value as i64, args);
    }

    export format_to(writer: mut StringWriter, value: i32, args: FormatArgs) {
        format_to(writer, value as i64, args);
    }

    export format_to(writer: mut StringWriter, value: int, args: FormatArgs) {
        format_to(writer, value as i64, args);
    }

    export format_to(writer: mut StringWriter, value: str, args: FormatArgs) {
        writer.write(value);
    }
    
    export format_to(writer: mut StringWriter, value: u8, args: FormatArgs) {
        format_to(writer, value as u64, args);
    }

    export format_to(writer: mut StringWriter, value: u16, args: FormatArgs) {
        format_to(writer, value as u64, args);
    }

    export format_to(writer: mut StringWriter, value: u32, args: FormatArgs) {
        format_to(writer, value as u64, args);
    }

    export format_to(writer: mut StringWriter, value: usize, args: FormatArgs) {
        format_to(writer, value as u64, args);
    }

    export format_to(writer: mut StringWriter, value: f32, args: FormatArgs) {
        let n = 0;
        let string = "";
        __c__("""
char buf[64];
n = snprintf(buf, sizeof(buf), "%.9g", value);
string = HZSTD_STRING_FROM_CSTR(buf);
        """);
        if n > 0 && n < 64 {
            writer.write(string);
        }
    }

    export format_to(writer: mut StringWriter, value: f64, args: FormatArgs) {
        let n = 0;
        let string = "";
        __c__("""
char buf[64];
n = snprintf(buf, sizeof(buf), "%.17g", value);
string = HZSTD_STRING_FROM_CSTR(buf);
        """);
        if n > 0 && n < 64 {
            writer.write(string);
        }
    }

    export format_to(writer: mut StringWriter, value: real, args: FormatArgs) {
        format_to(writer, value as f64, args);
    }

    export format_to(writer: mut StringWriter, value: fs.Error, args: FormatArgs) {
        let num = 0;
        __c__("num = value;");
        format_to(writer, num, args);
    }

    export format_to(writer: mut StringWriter, value: none, args: FormatArgs) {
        format_to(writer, "none", args);
    }

    export format_to(writer: mut StringWriter, value: null, args: FormatArgs) {
        format_to(writer, "null", args);
    }

    export format_to(writer: mut StringWriter, value: Vec2f, args: FormatArgs) {
        format_to(writer, "(", args);
        format_to(writer, value.x, args);
        format_to(writer, ", ", args);
        format_to(writer, value.y, args);
        format_to(writer, ")", args);
    }

    export format_to(writer: mut StringWriter, value: mut _Vec2<f32>, args: FormatArgs) {
        format_to(writer, value as Vec2f, args);
    }
}

extern C noemit struct cJSON {};

extern C hzstd_json_parse(allocator: Allocator, data: str, error: hzstd_str_ref_t): cJSON | none :: final;
extern C hzstd_json_create_string(allocator: Allocator, data: str): cJSON :: final;
extern C hzstd_json_create_number(allocator: Allocator, data: real): cJSON :: final;
extern C hzstd_json_create_object(allocator: Allocator): cJSON :: final;
extern C hzstd_json_create_array(allocator: Allocator): cJSON :: final;

extern C hzstd_json_object_has_attribute(json: cJSON, name: str): bool :: final;
extern C hzstd_json_is_string(json: cJSON): bool :: final;
extern C hzstd_json_is_object(json: cJSON): bool :: final;
extern C hzstd_json_is_bool(json: cJSON): bool :: final;
extern C hzstd_json_is_true(json: cJSON): bool :: final;
extern C hzstd_json_is_false(json: cJSON): bool :: final;
extern C hzstd_json_is_number(json: cJSON): bool :: final;
extern C hzstd_json_is_array(json: cJSON): bool :: final;
extern C hzstd_json_is_null(json: cJSON): bool :: final;

extern C hzstd_json_get_string_value(allocator: Allocator, json: cJSON): hzstd_str_ref_t | none :: final;
extern C hzstd_json_get_number_value(allocator: Allocator, json: cJSON): real :: final;

extern C hzstd_json_get_object_item(allocator: Allocator, json: cJSON, name: str): cJSON | none :: final;
extern C hzstd_json_get_array_size(allocator: Allocator, json: cJSON): usize :: final;
extern C hzstd_json_get_array_item(allocator: Allocator, json: cJSON, index: usize): cJSON :: final;

extern C hzstd_json_add_item_to_object(allocator: Allocator, object: cJSON, name: str, item: cJSON): bool :: final;
extern C hzstd_json_add_item_to_array(allocator: Allocator, object: cJSON, item: cJSON): bool :: final;

extern C hzstd_json_print_unformatted(allocator: Allocator, json: cJSON): str :: final;
extern C hzstd_json_print(allocator: Allocator, json: cJSON): str :: final;


namespace json {
    struct Error {
        error: str;
    };

    struct Value {
        allocator: Allocator;
        data: cJSON;

        struct Proxy {
            json: Value;
            attribute: str;

            to<T>() {
                if comptime T == type<str> {
                    let obj = hzstd_json_get_object_item(this.json.allocator, this.json.data, this.attribute);
                    if obj {
                        let value = hzstd_json_get_string_value(this.json.allocator, obj);
                        if value {
                            return value.data;
                        }
                        sys.panic("JSON value is not of type String");
                    }
                    sys.panic("JSON object does not have attribute");
                } 
                else if T == type<real> {
                    let obj = hzstd_json_get_object_item(this.json.allocator, this.json.data, this.attribute);
                    if obj {
                        let value = hzstd_json_get_number_value(this.json.allocator, obj);
                        return value;
                    }
                    sys.panic("JSON object does not have attribute");
                }
                else {
                    static_assert(false, "Type not supported");
                }
            }

            operator[](index: str): Result<Proxy, Error> {
                // String access to a proxy, so the parent must be an object
                if hzstd_json_object_has_attribute(this.json.data, this.attribute) {
                    // Already exists, check type
                    if !hzstd_json_is_object(this.json.data) {
                        sys.panic("JSON was expected to be an object");
                    }

                    let obj = hzstd_json_get_object_item(this.json.allocator, this.json.data, this.attribute);
                    if obj {
                        return Result<Proxy, Error>.Ok({ json: { allocator: this.json.allocator, data: obj }, attribute: index });
                    }
                    sys.panic("JSON object does not have attribute");
                }
                else {
                    // Does not exist yet, create
                    let newObj = hzstd_json_create_object(this.json.allocator);
                    hzstd_json_add_item_to_object(this.json.allocator, this.json.data, this.attribute, newObj);
                    return Result<Proxy, Error>.Ok({ json: { allocator: this.json.allocator, data: newObj }, attribute: index });
                }
            }

            operator:=(value: str): void {
                let item = hzstd_json_create_string(this.json.allocator, value);
                let success = hzstd_json_add_item_to_object(this.json.allocator, this.json.data, this.attribute, item);
                assert(success);
            }

            operator:=(value: real): void {
                let item = hzstd_json_create_number(this.json.allocator, value);
                let success = hzstd_json_add_item_to_object(this.json.allocator, this.json.data, this.attribute, item);
                assert(success);
            }

            operator:=(value: Value): void {
                let success = hzstd_json_add_item_to_object(this.json.allocator, this.json.data, this.attribute, value.data);
                assert(success);
            }

            push(value: Value): void {
                if hzstd_json_object_has_attribute(this.json.data, this.attribute) {
                    let obj = hzstd_json_get_object_item(this.json.allocator, this.json.data, this.attribute);
                    if obj {
                        assert(hzstd_json_is_array(obj));
                        hzstd_json_add_item_to_array(this.json.allocator, obj, value.data);
                        return;
                    }
                    sys.panic("JSON object does not have attribute");
                }
                else {
                    sys.panic("JSON attribute to push into does not exist");
                }
            }
        }

        operator[](index: int): Result<Proxy, Error> {
            return Result<Proxy, Error>.Ok({
                json: this,
                attribute: "test",
            });
        }

        operator[](index: str): Result<Proxy, Error> {
            return Result<Proxy, Error>.Ok({
                json: this,
                attribute: index,
            });
        }

        struct PrintOptions {
            pretty: bool = false;
        }

        print(options: PrintOptions) {
            if (options.pretty) {
                return hzstd_json_print(this.allocator, this.data);
            }
            else {
                return hzstd_json_print_unformatted(this.allocator, this.data);
            }
        }

    }

    parse(data: str): Result<Value, Error> {
        return parseWithAllocator(Alloc.arena(), data);
    }

    parseWithAllocator(allocator: Allocator, data: str): Result<Value, Error> {
        let error = hzstd_str_ref_t { data: "" };
        const cjson = hzstd_json_parse(allocator, data, error);
        if cjson {
            return Result<Value, Error>.Ok({
                allocator: allocator,
                data: cjson,
            } with allocator);
        }
        return Result<Value, Error>.Err({ error: error.data });
    }

    object(): Value {
        let allocator = Alloc.arena();
        let obj = hzstd_json_create_object(allocator);
        return { allocator: allocator, data: obj };
    }

    array(): Value {
        let allocator = Alloc.arena();
        let obj = hzstd_json_create_array(allocator);
        return { allocator: allocator, data: obj };
    }
}

struct Foo {};

foobar2(): Result<Foo, json.Error> {
    const data = "{\"name\":\"Alice\",\"age\":25,\"active\":true,\"numbers\":[1,2,3],\"nested\":{\"x\":10,\"y\":\"hello\"},\"msg\":\"Hello\\nWorld!\"}";
    let j = json.parse(data)?!;

    let a = j["name"]?!.to<str>();
    let b = j["age"]?!.to<real>();
    let c = j["nested"]?!["y"]?!.to<str>();
    fmt.println("Parsed:", a, b, c);
    return Result<Foo, json.Error>.Ok({});
}

// createcJSONExample(): Result<Foo, json.Error> {
//     const resolutionNumbers = [3]Vec2 {
//         Vec2(1280, 720),
//         Vec2(1920, 1080),
//         Vec2(3840, 2160),
//     };

//     let value = json.object();
//     value["name"]?! := "Awesome 4K";

//     value["resolutions"]?! := json.array();

//     for (let i = 0; i < resolutionNumbers.length; i++) {
//         let res = resolutionNumbers[i];

//         value["resolutions"]?!.push(do {
//             let v = json.object();
//             v["width"]?! := res.x;
//             v["height"]?! := res.y;
//             v;
//         });
//     }

//     fmt.println("RESULT: ", value.print({
//         pretty: true
//     }));

//     return Result<Foo, json.Error>.Ok({});
// }

export foobar() {
    let result = foobar2();
    if !result {
        fmt.println("Error:", result.error);
    }
    else {
        fmt.println("Success!");
    }
    // createcJSONExample();
}

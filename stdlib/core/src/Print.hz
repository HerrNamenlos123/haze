
__c__("#include <stdio.h>");

namespace builtin {
    export extern C noemit printf(fmt: ccstr, ...);
}

export foo() {
    let a = MemoryBuffer(20);
    a.write("Hello", 0);
    a.write(" ", 5);
    a.write("World!", 6);
    const b = a;

    fmt.println("\nResult: ", b.toString());
    fmt.format();
}

namespace fmt {
    export struct FormatArgs {
        formatSpecifier: str = "";
    }

    export opaque struct StringWriter {
        buffer: MemoryBuffer | none;
        written: int = 0;

        constructor(buffer?: MemoryBuffer) {
            return unique StringWriter {
                buffer: buffer,
            };
        }

        mut write(value: str) {        
            if this.buffer {
                // __c__("memcpy(this->buffer + this->length, value.data, value.length);");
                // for i in 0..value.len {
                //     this.buffer[length + i] = value[i];
                // }
            }
            this.written += value.length;
        }

        const toString() {
            const buffer = this.buffer;
            if (buffer) {
                const cBuffer = buffer;
                return cBuffer.toString();
            }
            else {
                return "";
            }
        }
    }

    format() {
        let writer = StringWriter(none);
        let writer2 = format_to(writer, 187, {});
        const written = writer2.written;

        let writer3 = StringWriter(MemoryBuffer(written));
        let writer4 = format_to(writer3, 187, {});
        const immutableWriter = writer4;
        fmt.println("Formatted: ", immutableWriter.toString());
    }

    export format_to(writer: unique mut StringWriter, value: int, args: FormatArgs) {
        let v = value;
        if v < 0 {
            writer.write("-");
            if v == -2147483648 {
                writer.write("2147483648");
                return;
            }
            v = -v;
        }

        // Find highest divisor
        let div = 1;
        while v / div >= 10 {
            div *= 10;
        }

        while div > 0 {
            let digit = v / div;
            writer.write(digitToStr(digit));
            v %= div;
            div /= 10;
        }

        return writer;
    }

    digitToStr(digit: int): str {
        assert(digit >= 0 && digit <= 9);
        let result: str = "";
        __c__("static const char* digits[] = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\" };");
        __c__("result = HZSTD_STRING(digits[digit - '0'], 1);");
        return result;
    }

    // export format_to(writer: StringWriter, value: i8, args: FormatArgs) {
    //     format_to(writer, value as int, args);
    // }

    // export format_to(writer: StringWriter, value: i16, args: FormatArgs) {
    //     format_to(writer, value as int, args);
    // }

    // export format_to(writer: StringWriter, value: i32, args: FormatArgs) {
    //     format_to(writer, value as int, args);
    // }

    // export format_to(writer: StringWriter, value: i64, args: FormatArgs) {
    //     format_to(writer, value as int, args);
    // }

    export print(args: ...) {
        for comptime arg in args {
            if comptime typeof(arg) == int || typeof(arg) == type<mut int> {
                const value = arg;
                // builtin.printf("%lld", arg);
                __c__("printf(\"%\"PRId64, value);");
            }
            else if typeof(arg) == str {
                const s = arg;
                __c__("fwrite(s.data, 1, s.length, stdout);");
                // builtin.printf("%s", arg);
            }
            else if typeof(arg) == type<str> {
                const s = arg;
                __c__("fwrite(s.data, 1, s.length, stdout);");
                // builtin.printf("%s", arg);
            }
            else if typeof(arg) == bool {
                if arg {
                    builtin.printf("true");
                }
                else {
                    builtin.printf("false");
                }
            }
            else if typeof(arg) == type<usize> {
                builtin.printf("%zu", arg);
            }
            else if typeof(arg) == type<real> || typeof(arg) == type<mut real> {
                builtin.printf("%f", arg);
            }
            else if typeof(arg) == type<u8> || typeof(arg) == type<u16> || typeof(arg) == type<u32> {
                const value = arg;
                __c__("printf(\"%\"PRIu8, value);");
            }
            else if typeof(arg) == type<u64> {
                const value = arg;
                __c__("printf(\"%\"PRIu64, value);");
            }
            else if typeof(arg) == type<i8> || typeof(arg) == type<i16> || typeof(arg) == type<i32> {
                const value = arg;
                __c__("printf(\"%\"PRId8, value);");
            }
            else if typeof(arg) == type<i64> {
                const value = arg;
                __c__("printf(\"%\"PRId64, value);");
            }
            else if typeof(arg) == type<Vec2> || typeof(arg) == type<Vec2> {
                builtin.printf("(%f, %f)", arg.x, arg.y);
            }
            else if typeof(arg) == type<Vec3> || typeof(arg) == type<Vec3> {
                builtin.printf("(%f, %f, %f)", arg.x, arg.y, arg.z);
            }
            else if typeof(arg) == type<Vec4> || typeof(arg) == type<Vec4> {
                builtin.printf("(%f, %f, %f, %f)", arg.x, arg.y, arg.z, arg.w);
            }
            else {
                static_assert(false, typeof(arg).name);
                static_assert(false, "Type not yet supported in print");
            }
        }
    }

    export println(args: ...) {
        for comptime arg, i in args {
            print(arg);
            if comptime i != args.length - 1 {
                print(" ");
            }
        }
        print("\n");
    }
}
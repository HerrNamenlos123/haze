
__c__("#include <stdio.h>");

namespace builtin {
    export extern "C" noemit printf(fmt: str, ...);
}

namespace fmt {
    export struct FormatArgs {
        formatSpecifier: str = "";
    }

    struct StringWriter {
        buffer: u8*;
        length: usize;

        write(value: u8[]) {        
            if this.buffer != nullptr {
                __c__("memcpy(this->buffer + this->length, value.data, value.length);");
                // for i in 0..value.len {
                //     this.buffer[length + i] = value[i];
                // }
            }
            this.length += value.length;
        }

        write(c: u8) {
            if this.buffer != nullptr {
                __c__("this->buffer[this->length] = c;");
            }
            this.length += 1;
        }
    }

    format<T>(arena: Arena&, value: T, args: FormatArgs) {
        const writer = StringWriter { buffer: null, length: 0 };
        format_to(writer, value, args);       // pass 1: measure length
        const str = arena.alloc<u8>(writer.length);  // allocate exact size
        const writer2 = StringWriter { buffer: str, length: 0 };
        format_to(writer2, value, args);      // pass 2: write actual bytes
        return str;
    }

    format_to(writer: StringWriter&, value: i32) {
        format_integer(writer, value as int);
    }

    format_integer(writer: StringWriter&, value: int) {
        let buf = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // Space for int.max = 9223372036854775807
        let a = [5][:];
        let x = buf[:];
        // writer.write(buf[:]);
    }
}

export print(args: ...) {
    for comptime arg in args {
        if comptime typeof(arg) == int {
            builtin.printf("%ld", arg);
        }
        else if typeof(arg) == str {
            builtin.printf("%s", arg);
        }
        else if typeof(arg) == bool {
            if arg {
                builtin.printf("true");
            }
            else {
                builtin.printf("false");
            }
        }
        else if typeof(arg) == usize {
            builtin.printf("%zu", arg);
        }
        else if typeof(arg) == real {
            builtin.printf("%f", arg);
        }
        else if typeof(arg) == u8 || typeof(arg) == u16 || typeof(arg) == u32 {
            builtin.printf("%u", arg);
        }
        else if typeof(arg) == u64 {
            builtin.printf("%lu", arg);
        }
        else if typeof(arg) == i8 || typeof(arg) == i16 || typeof(arg) == i32 {
            builtin.printf("%d", arg);
        }
        else if typeof(arg) == i64 {
            builtin.printf("%ld", arg);
        }
        else if typeof(arg) == Vec2 || typeof(arg) == type<Vec2&> {
            builtin.printf("(%f, %f)", arg.x, arg.y);
        }
        else if typeof(arg) == Vec3 || typeof(arg) == type<Vec3&> {
            builtin.printf("(%f, %f, %f)", arg.x, arg.y, arg.z);
        }
        else if typeof(arg) == Vec4 || typeof(arg) == type<Vec4&> {
            builtin.printf("(%f, %f, %f, %f)", arg.x, arg.y, arg.z, arg.w);
        }
        else {
            static_assert(false, "Type not yet supported in print");
        }
    }
}

export println(args: ...) {
    for comptime arg, i in args {
        print(arg);
        if i != args.length - 1 as usize {
            print(" ");
        }
    }
    print("\n");
}


export __c__("#include \"wgpu.h\"");
__c__("#include \"wgpu_impl.c\"");

export extern C noemit wgpu_init(glfwWindow: cptr) :: final;
export extern C noemit wgpu_start(glfwWindow: cptr) :: final;
export extern C noemit wgpu_end(glfwWindow: cptr) :: final;

export struct Future {
    id: u64;

    constructor(future: inline ffi.WGPUFuture): const Future {
        return {
            id: future.id,
        };
    }
}

export struct Surface {
    handle: mut ffi.WGPUSurfaceImpl;
}

export struct Adapter {
    handle: mut ffi.WGPUAdapterImpl;
}

export struct RequestAdapterOptions {
    featureLevel: FeatureLevel = FeatureLevel.Core;
    powerPreference: PowerPreference = PowerPreference.Undefined;
    forceFallbackAdapter: bool = false;
    backendType: BackendType = BackendType.Undefined;
    compatibleSurface: mut Surface | none = none;
}

export type RequestAdapterCallback = (status: RequestAdapterStatus, adapter: mut Adapter, message: str) => void :: final;
export struct RequestAdapterCallbackInfo {
    callback: RequestAdapterCallback;
    mode: CallbackMode = CallbackMode.WaitAnyOnly;
    userdata1: cptr = none;
    userdata2: cptr = none;
}

requestAdapterCallbackProxy(status: ffi.WGPURequestAdapterStatus, adapter: mut ffi.WGPUAdapterImpl, message: inline ffi.WGPUStringView, userdata1: cptr, userdata2: cptr): void :: final {
    do unsafe {
        let callback: RequestAdapterCallback = uninitialized;
        __c__("callback = (void*)userdata1;");
        let msg = "";
        __c__("msg.data = message.data;");
        __c__("msg.length = message.length;");
        callback(RequestAdapterStatusFromFFI(status), Adapter { handle: adapter }, msg);
    }
}

export struct Instance {
    handle: mut ffi.WGPUInstanceImpl;

    requestAdapter(adapterOpts: RequestAdapterOptions | none, callbackInfo: RequestAdapterCallbackInfo) {

        let callback = callbackInfo.callback;
        let userdata1: cptr = none;
        __c__("userdata1 = (void*)callback;"); // Pass the function pointer to the highlevel callback into the lowlevel hook

        let ffiCallbackInfo = inline ffi.WGPURequestAdapterCallbackInfo {
            nextInChain: none,
            callback: requestAdapterCallbackProxy,
            mode: CallbackModeToFFI(callbackInfo.mode),
            userdata1: userdata1,
            userdata2: none,
        };

        if adapterOpts {
            let surface = adapterOpts.compatibleSurface;
            let compatibleSurface: mut ffi.WGPUSurfaceImpl | none = none;
            if surface {
                compatibleSurface = surface.handle;
            }

            return Future(
                ffi.wgpuInstanceRequestAdapter(this.handle, {
                    nextInChain: none,
                    featureLevel: FeatureLevelToFFI(adapterOpts.featureLevel),
                    powerPreference: PowerPreferenceToFFI(adapterOpts.powerPreference),
                    forceFallbackAdapter: adapterOpts.forceFallbackAdapter,
                    backendType: BackendTypeToFFI(adapterOpts.backendType),
                    compatibleSurface: compatibleSurface,
                }, ffiCallbackInfo)
            );
        }
        else {
            return Future(ffi.wgpuInstanceRequestAdapter(this.handle, none, ffiCallbackInfo));
        }
    }
}

export createInstance() { 
    let instance_desc = ffi.WGPUInstanceDescriptor {
        nextInChain: none,
        features: {
            nextInChain: none,
            timedWaitAnyEnable: false,
            timedWaitAnyMaxCount: 0,
        }
    };
    let instance = ffi.wgpuCreateInstance(instance_desc);
    if instance {
        return Instance {
            handle: instance,
        };
    }
    return none;
}

export init(handle: cptr) {
    wgpu_init(handle);
}
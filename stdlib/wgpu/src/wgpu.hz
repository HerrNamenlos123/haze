
__c__("#pragma clang diagnostic ignored \"-Wincompatible-pointer-types-discards-qualifiers\"");

export __c__("#include \"wgpu.h\"");
__c__("#include \"wgpu_impl.c\"");

export struct QuerySet {
    handle: mut ffi.WGPUQuerySetImpl;
}

extern C const WGPU_DEPTH_SLICE_UNDEFINED: u32;

export struct RequestAdapterOptions {
    featureLevel: FeatureLevel = FeatureLevel.Core;
    powerPreference: PowerPreference = PowerPreference.Undefined;
    forceFallbackAdapter: bool = false;
    backendType: BackendType = BackendType.Undefined;
    compatibleSurface: mut Surface | none = none;
}

export type RequestAdapterCallback = (status: RequestAdapterStatus, adapter: mut Adapter, message: str) => void :: final;
export struct RequestAdapterCallbackInfo {
    callback: RequestAdapterCallback;
    mode: CallbackMode = CallbackMode.WaitAnyOnly;
}

requestAdapterCallbackProxy(status: ffi.WGPURequestAdapterStatus, adapter: mut ffi.WGPUAdapterImpl, message: inline ffi.WGPUStringView, userdata1: cptr, userdata2: cptr): void :: final {
    do unsafe {
        let callback: Box<RequestAdapterCallback> = uninitialized;
        __c__("callback = (void*)userdata1;");
        callback.value(fromFFI(status), fromFFI(adapter), fromFFI(message));
    }
}



export struct Limits {
    maxTextureDimension1D: u32 = 0;
    maxTextureDimension2D: u32 = 0;
    maxTextureDimension3D: u32 = 0;
    maxTextureArrayLayers: u32 = 0;
    maxBindGroups: u32 = 0;
    maxBindGroupsPlusVertexBuffers: u32 = 0;
    maxBindingsPerBindGroup: u32 = 0;
    maxDynamicUniformBuffersPerPipelineLayout: u32 = 0;
    maxDynamicStorageBuffersPerPipelineLayout: u32 = 0;
    maxSampledTexturesPerShaderStage: u32 = 0;
    maxSamplersPerShaderStage: u32 = 0;
    maxStorageBuffersPerShaderStage: u32 = 0;
    maxStorageTexturesPerShaderStage: u32 = 0;
    maxUniformBuffersPerShaderStage: u32 = 0;
    maxUniformBufferBindingSize: u64 = 0;
    maxStorageBufferBindingSize: u64 = 0;
    minUniformBufferOffsetAlignment: u32 = 0;
    minStorageBufferOffsetAlignment: u32 = 0;
    maxVertexBuffers: u32 = 0;
    maxBufferSize: u64 = 0;
    maxVertexAttributes: u32 = 0;
    maxVertexBufferArrayStride: u32 = 0;
    maxInterStageShaderVariables: u32 = 0;
    maxColorAttachments: u32 = 0;
    maxColorAttachmentBytesPerSample: u32 = 0;
    maxComputeWorkgroupStorageSize: u32 = 0;
    maxComputeInvocationsPerWorkgroup: u32 = 0;
    maxComputeWorkgroupSizeX: u32 = 0;
    maxComputeWorkgroupSizeY: u32 = 0;
    maxComputeWorkgroupSizeZ: u32 = 0;
    maxComputeWorkgroupsPerDimension: u32 = 0;

    toFFI() {
        return ffi.WGPULimits {
            nextInChain: none,
            maxTextureDimension1D: this.maxTextureDimension1D,
            maxTextureDimension2D: this.maxTextureDimension2D,
            maxTextureDimension3D: this.maxTextureDimension3D,
            maxTextureArrayLayers: this.maxTextureArrayLayers,
            maxBindGroups: this.maxBindGroups,
            maxBindGroupsPlusVertexBuffers: this.maxBindGroupsPlusVertexBuffers,
            maxBindingsPerBindGroup: this.maxBindingsPerBindGroup,
            maxDynamicUniformBuffersPerPipelineLayout: this.maxDynamicUniformBuffersPerPipelineLayout,
            maxDynamicStorageBuffersPerPipelineLayout: this.maxDynamicStorageBuffersPerPipelineLayout,
            maxSampledTexturesPerShaderStage: this.maxSampledTexturesPerShaderStage,
            maxSamplersPerShaderStage: this.maxSamplersPerShaderStage,
            maxStorageBuffersPerShaderStage: this.maxStorageBuffersPerShaderStage,
            maxStorageTexturesPerShaderStage: this.maxStorageTexturesPerShaderStage,
            maxUniformBuffersPerShaderStage: this.maxUniformBuffersPerShaderStage,
            maxUniformBufferBindingSize: this.maxUniformBufferBindingSize,
            maxStorageBufferBindingSize: this.maxStorageBufferBindingSize,
            minUniformBufferOffsetAlignment: this.minUniformBufferOffsetAlignment,
            minStorageBufferOffsetAlignment: this.minStorageBufferOffsetAlignment,
            maxVertexBuffers: this.maxVertexBuffers,
            maxBufferSize: this.maxBufferSize,
            maxVertexAttributes: this.maxVertexAttributes,
            maxVertexBufferArrayStride: this.maxVertexBufferArrayStride,
            maxInterStageShaderVariables: this.maxInterStageShaderVariables,
            maxColorAttachments: this.maxColorAttachments,
            maxColorAttachmentBytesPerSample: this.maxColorAttachmentBytesPerSample,
            maxComputeWorkgroupStorageSize: this.maxComputeWorkgroupStorageSize,
            maxComputeInvocationsPerWorkgroup: this.maxComputeInvocationsPerWorkgroup,
            maxComputeWorkgroupSizeX: this.maxComputeWorkgroupSizeX,
            maxComputeWorkgroupSizeY: this.maxComputeWorkgroupSizeY,
            maxComputeWorkgroupSizeZ: this.maxComputeWorkgroupSizeZ,
            maxComputeWorkgroupsPerDimension: this.maxComputeWorkgroupsPerDimension,
        };
    }
}

export struct QueueDescriptor {
    debugLabel?: str;
}

export struct DeviceDescriptor {
    debugLabel?: str;
    requiredFeatures: []FeatureName = [];
    requiredLimits: Limits | none = none;
    defaultQueue: QueueDescriptor = default;
    // deviceLostCallbackInfo: DeviceLostCallbackInfo | none;
    // uncapturedErrorCallbackInfo: inline WGPUUncapturedErrorCallbackInfo;
}

export type RequestDeviceCallback = (status: RequestDeviceStatus, device: mut Device, message: str) => void :: final;
export struct RequestDeviceCallbackInfo {
    mode: CallbackMode = CallbackMode.WaitAnyOnly;
    callback: RequestDeviceCallback;
}

requestDeviceCallbackProxy(status: ffi.WGPURequestDeviceStatus, device: mut ffi.WGPUDeviceImpl, message: inline ffi.WGPUStringView, userdata1: cptr, userdata2: cptr): void :: final {
    do unsafe {
        let callback: Box<RequestDeviceCallback> = uninitialized;
        __c__("callback = (void*)userdata1;");
        callback.value(fromFFI(status), Device { handle: device }, fromFFI(message));
    }
}


export createInstance() { 
    let instance = ffi.wgpuCreateInstance({
        nextInChain: none,
        features: {
            nextInChain: none,
            timedWaitAnyEnable: false,
            timedWaitAnyMaxCount: 0,
        }
    });
    if instance {
        return fromFFI(instance);
    }
    return none;
}
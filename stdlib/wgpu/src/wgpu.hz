
export __c__("#include \"wgpu.h\"");
__c__("#include \"wgpu_impl.c\"");

export struct Future {
    id: u64;

    constructor(future: inline ffi.WGPUFuture): const Future {
        return {
            id: future.id,
        };
    }
}

export struct Surface {
    handle: mut ffi.WGPUSurfaceImpl;

    getCapabilities(adapter: mut Adapter): Result<SurfaceCapabilities, none> {
        do unsafe {
            let caps = ffi.WGPUSurfaceCapabilities {
                nextInChain: none,
                usages: 0,
                formatCount: 0,
                formats: none,
                presentModeCount: 0,
                presentModes: none,
                alphaModeCount: 0,
                alphaModes: none,
            };
            let status = ffi.wgpuSurfaceGetCapabilities(this.handle, adapter.handle, caps);
            if status != ffi.WGPUStatus_Success {
                return none;
            }
            return SurfaceCapabilities.fromFFI(caps);
        }
    }

    configure(config: SurfaceConfiguration) {
        ffi.wgpuSurfaceConfigure(this.handle, config.toFFI());
    }

    getCurrentTexture() {
        let texture = ffi.WGPUSurfaceTexture {
            nextInChain: none,
            texture: none,
            status: ffi.WGPUSurfaceGetCurrentTextureStatus_SuccessOptimal, // will be overwritten
        };
        ffi.wgpuSurfaceGetCurrentTexture(this.handle, texture);
        return SurfaceTexture.fromFFI(texture);
    }

    present(): Result<none, none> {
        let status = ffi.wgpuSurfacePresent(this.handle);
        if status == ffi.WGPUStatus_Success {
            return Result<none, none>.Ok(none);
        }
        return Result<none, none>.Err(none);
    }
}

export struct TextureViewDescriptor {
    label: str;
    format: TextureFormat;
    dimension: TextureViewDimension;
    baseMipLevel: u32;
    mipLevelCount: u32;
    baseArrayLayer: u32;
    arrayLayerCount: u32;
    aspect: TextureAspect;
    usage: TextureUsage;

    static fromFFI(conf: ffi.WGPUTextureViewDescriptor) {
        let c = TextureViewDescriptor {
            label: viewToStr(conf.label),
            format: TextureFormatFromFFI(conf.format),
            dimension: TextureViewDimensionFromFFI(conf.dimension),
            baseMipLevel: conf.baseMipLevel,
            mipLevelCount: conf.mipLevelCount,
            baseArrayLayer: conf.baseArrayLayer,
            arrayLayerCount: conf.arrayLayerCount,
            aspect: TextureAspectFromFFI(conf.aspect),
            usage: textureUsageFromFFI(conf.usage),
        };
        return c;
    }

    toFFI() {
        let c = ffi.WGPUTextureViewDescriptor {
            nextInChain: none,
            label: strToView(this.label),
            format: TextureFormatToFFI(this.format),
            dimension: TextureViewDimensionToFFI(this.dimension),
            baseMipLevel: this.baseMipLevel,
            mipLevelCount: this.mipLevelCount,
            baseArrayLayer: this.baseArrayLayer,
            arrayLayerCount: this.arrayLayerCount,
            aspect: TextureAspectToFFI(this.aspect),
            usage: textureUsageToFFI(this.usage),
        }
        return c;
    }
}

export struct CommandEncoderDescriptor {
    label: str;

    static fromFFI(conf: ffi.WGPUCommandEncoderDescriptor) {
        let c = CommandEncoderDescriptor {
            label: viewToStr(conf.label),
        };
        return c;
    }

    toFFI() {
        let c = ffi.WGPUCommandEncoderDescriptor {
            nextInChain: none,
            label: strToView(this.label),
        }
        return c;
    }
}

export struct Texture {
    handle: mut ffi.WGPUTextureImpl;

    createView(viewDescriptor?: TextureViewDescriptor): Result<mut TextureView, none> {
        let vd = none as ffi.WGPUTextureViewDescriptor | none;
        let vdd = viewDescriptor;
        if vdd {
            vd = vdd.toFFI();
        }
        let textureView = ffi.wgpuTextureCreateView(this.handle, vd);
        if textureView {
            return TextureView {
                handle: textureView,
            };
        }
        return none;
    }
}

export struct RenderPassEncoder {
    handle: mut ffi.WGPURenderPassEncoderImpl;

    end() {
        ffi.wgpuRenderPassEncoderEnd(this.handle);
    }
}

export struct TextureView {
    handle: mut ffi.WGPUTextureViewImpl;
}

export struct CommandBuffer {
    handle: mut ffi.WGPUCommandBufferImpl;
}

export struct CommandBufferDescriptor {
    label: str;

    static fromFFI(conf: ffi.WGPUCommandBufferDescriptor) {
        let c = CommandBufferDescriptor {
            label: viewToStr(conf.label),
        };
        return c;
    }

    toFFI() {
        let c = ffi.WGPUCommandBufferDescriptor {
            nextInChain: none,
            label: strToView(this.label),
        }
        return c;
    }
}

export struct RenderPassDepthStencilAttachment {
    view: mut TextureView;
    depthLoadOp: LoadOp;
    depthStoreOp: StoreOp;
    depthClearValue: f32;
    depthReadOnly: bool;
    stencilLoadOp: LoadOp;
    stencilStoreOp: StoreOp;
    stencilClearValue: u32;
    stencilReadOnly: bool;

    static fromFFI(conf: ffi.WGPURenderPassDepthStencilAttachment) {
        let c = RenderPassDepthStencilAttachment {
            view: TextureView { handle: conf.view },
            depthLoadOp: LoadOpFromFFI(conf.depthLoadOp),
            depthStoreOp: StoreOpFromFFI(conf.depthStoreOp),
            depthClearValue: conf.depthClearValue,
            depthReadOnly: conf.depthReadOnly,
            stencilLoadOp: LoadOpFromFFI(conf.stencilLoadOp),
            stencilStoreOp: StoreOpFromFFI(conf.stencilStoreOp),
            stencilClearValue: conf.stencilClearValue,
            stencilReadOnly: conf.stencilReadOnly,
        };
        return c;
    }

    toFFI() {
        let c = ffi.WGPURenderPassDepthStencilAttachment {
            view: this.view.handle,
            depthLoadOp: LoadOpToFFI(this.depthLoadOp),
            depthStoreOp: StoreOpToFFI(this.depthStoreOp),
            depthClearValue: this.depthClearValue,
            depthReadOnly: this.depthReadOnly,
            stencilLoadOp: LoadOpToFFI(this.stencilLoadOp),
            stencilStoreOp: StoreOpToFFI(this.stencilStoreOp),
            stencilClearValue: this.stencilClearValue,
            stencilReadOnly: this.stencilReadOnly,
        }
        return c;
    }
}

export struct QuerySet {
    handle: mut ffi.WGPUQuerySetImpl;
}

export struct RenderPassTimestampWrites {
    querySet: mut QuerySet;
    beginningOfPassWriteIndex: u32;
    endOfPassWriteIndex: u32;

    static fromFFI(conf: ffi.WGPURenderPassTimestampWrites) {
        let c = RenderPassTimestampWrites {
            querySet: QuerySet { handle: conf.querySet },
            beginningOfPassWriteIndex: conf.beginningOfPassWriteIndex,
            endOfPassWriteIndex: conf.endOfPassWriteIndex,
        };
        return c;
    }

    toFFI() {
        let c = ffi.WGPURenderPassTimestampWrites {
            querySet: this.querySet.handle,
            beginningOfPassWriteIndex: this.beginningOfPassWriteIndex,
            endOfPassWriteIndex: this.endOfPassWriteIndex,
        }
        return c;
    }
}

export struct RenderPassDescriptor {
    label: str = "";
    colorAttachments: []RenderPassColorAttachment = {};
    depthStencilAttachment: RenderPassDepthStencilAttachment | none = none;
    occlusionQuerySet: mut QuerySet | none = none;
    timestampWrites: RenderPassTimestampWrites | none = none;

    static fromFFI(conf: ffi.WGPURenderPassDescriptor) {
        let c = RenderPassDescriptor {
            label: viewToStr(conf.label),
            colorAttachments: {},
            depthStencilAttachment: none,
            occlusionQuerySet: none,
            timestampWrites: none,
        };

        for (let i = 0; i < conf.colorAttachmentCount; i++) {
            do unsafe {
                let e: ffi.WGPURenderPassColorAttachment = uninitialized;
                __c__("e = &((WGPURenderPassColorAttachment*)conf->colorAttachments)[i];");
                c.colorAttachments.push(RenderPassColorAttachment.fromFFI(e));
            }
        }

        let sa = none as ffi.WGPURenderPassDepthStencilAttachment | none;
        // This is assigned in C because of a constness mismatch we ignore
        __c__("sa = (WGPURenderPassDepthStencilAttachment*)conf->depthStencilAttachment;"); 
        if sa {
            c.depthStencilAttachment = RenderPassDepthStencilAttachment.fromFFI(sa);
        }

        let oq = conf.occlusionQuerySet;
        if oq {
            c.occlusionQuerySet = QuerySet { handle: oq };
        }

        let tw = none as ffi.WGPURenderPassTimestampWrites | none;
        // This is assigned in C because of a constness mismatch we ignore
        __c__("tw = (WGPURenderPassTimestampWrites*)conf->timestampWrites;"); 
        if tw {
            c.timestampWrites = RenderPassTimestampWrites.fromFFI(tw);
        }

        return c;
    }

    toFFI() {
        let c = ffi.WGPURenderPassDescriptor {
            nextInChain: none,
            label: strToView(this.label),
            colorAttachmentCount: 0,
            colorAttachments: none,
            depthStencilAttachment: none,
            occlusionQuerySet: none,
            timestampWrites: none,
        }

        let attachments: [](inline ffi.WGPURenderPassColorAttachment) = {};
        for (let i = 0; i < this.colorAttachments.length; i++) {
            attachments.push(this.colorAttachments[i].toInlineFFI());
        }

        __c__("c->colorAttachmentCount = hzstd_dynamic_array_size(attachments);");
        __c__("c->colorAttachments = hzstd_dynamic_array_raw_buffer(attachments);");

        let sa = this.depthStencilAttachment;
        if sa {
            c.depthStencilAttachment = sa.toFFI();
        }

        let oq = this.occlusionQuerySet;
        if oq {
            c.occlusionQuerySet = oq.handle;
        }

        let tw = this.timestampWrites;
        if tw {
            c.timestampWrites = tw.toFFI();
        }

        return c;
    }
}

export struct SurfaceTexture {
    texture: Texture | none;
    status: SurfaceGetCurrentTextureStatus;

    static fromFFI(conf: ffi.WGPUSurfaceTexture) {
        let c = SurfaceTexture {
            texture: none,
            status: SurfaceGetCurrentTextureStatusFromFFI(conf.status),
        };
        let t = conf.texture;
        if t {
            c.texture = Texture { handle: t };
        }
        return c;
    }

    toFFI() {
        let t = none as mut ffi.WGPUTextureImpl | none;
        let tt = this.texture;
        if tt {
            t = tt.handle;
        }
        let c = ffi.WGPUSurfaceTexture {
            nextInChain: none,
            texture: t,
            status: SurfaceGetCurrentTextureStatusToFFI(this.status),
        }
        return c;
    }
}

export struct SurfaceConfiguration {
    device: mut Device;
    format: TextureFormat = TextureFormat.Undefined;
    usage: TextureUsage = TextureUsage.None;
    width: u32 = 0;
    height: u32 = 0;
    viewFormats: []TextureFormat = {};
    alphaMode: CompositeAlphaMode = CompositeAlphaMode.Auto;
    presentMode: PresentMode = PresentMode.Undefined;

    static fromFFI(conf: ffi.WGPUSurfaceConfiguration) {
        let c = SurfaceConfiguration {
            device: Device { handle: conf.device },
            format: TextureFormatFromFFI(conf.format),
            usage: textureUsageFromFFI(conf.usage),
            width: conf.width,
            height: conf.height,
            viewFormats: {},
            alphaMode: CompositeAlphaModeFromFFI(conf.alphaMode),
            presentMode: PresentModeFromFFI(conf.presentMode),
        };

        for (let i = 0; i < conf.viewFormatCount; i++) {
            do unsafe {
                let e: TextureFormat = uninitialized;
                __c__("e = (int)((WGPUTextureFormat*)conf->viewFormats)[i];");
                c.viewFormats.push(e);
            }
        }

        return c;
    }

    toFFI() {
        let c = ffi.WGPUSurfaceConfiguration {
            nextInChain: none,
            device: this.device.handle,
            format: TextureFormatToFFI(this.format),
            usage: textureUsageToFFI(this.usage),
            width: this.width,
            height: this.height,
            viewFormatCount: 0,
            viewFormats: none,
            alphaMode: CompositeAlphaModeToFFI(this.alphaMode),
            presentMode: PresentModeToFFI(this.presentMode),
        }
        __c__("c->viewFormatCount = hzstd_dynamic_array_size(this->viewFormats);");
        __c__("c->viewFormats = hzstd_dynamic_array_raw_buffer(this->viewFormats);");
        return c;
    }
}

export enum bitflag TextureUsage {
    None = 0,
    CopySrc = 1,
    CopyDst = 2,
    TextureBinding = 4,
    StorageBinding = 8,
    RenderAttachment = 16,
}

textureUsageFromFFI(u: ffi.WGPUTextureUsage) {
    do unsafe {
        let usage: TextureUsage = uninitialized; // This is a bitflag
        __c__("usage = (int)u;");
        return usage;
    }
}

textureUsageToFFI(u: TextureUsage) {
    do unsafe {
        let usage: ffi.WGPUTextureUsage = uninitialized; // This is a bitflag
        __c__("usage = (int)u;");
        return usage;
    }
}

export struct SurfaceCapabilities {
    usages: TextureUsage = TextureUsage.None;
    formats: []TextureFormat = {};
    presentModes: []PresentMode = {};
    alphaModes: []CompositeAlphaMode = {};

    static fromFFI(caps: ffi.WGPUSurfaceCapabilities) {
        do unsafe {
            let c = SurfaceCapabilities {
                usages: textureUsageFromFFI(caps.usages),
            };

            for (let i = 0; i < caps.formatCount; i++) {
                do unsafe {
                    let e: TextureFormat = uninitialized;
                    __c__("e = (int)((WGPUTextureFormat*)caps->formats)[i];");
                    c.formats.push(e);
                }
            }

            for (let i = 0; i < caps.presentModeCount; i++) {
                do unsafe {
                    let p: PresentMode = uninitialized;
                    __c__("p = (int)((WGPUPresentMode*)caps->presentModes)[i];");
                    c.presentModes.push(p);
                }
            }

            for (let i = 0; i < caps.alphaModeCount; i++) {
                do unsafe {
                    let a: CompositeAlphaMode = uninitialized;
                    __c__("a = (int)((WGPUCompositeAlphaMode*)caps->alphaModes)[i];");
                    c.alphaModes.push(a);
                }
            }

            return c;
        }
    }

    toFFI() {
        do unsafe {
            let caps = ffi.WGPUSurfaceCapabilities {
                nextInChain: none,
                usages: textureUsageToFFI(this.usages),
                formatCount: 0,
                formats: none,
                presentModeCount: 0,
                presentModes: none,
                alphaModeCount: 0,
                alphaModes: none,
            };
            __c__("caps->formatCount = hzstd_dynamic_array_size(this->formats);");
            __c__("caps->formats = hzstd_dynamic_array_raw_buffer(this->formats);");
            __c__("caps->presentModeCount = hzstd_dynamic_array_size(this->presentModes);");
            __c__("caps->presentModes = hzstd_dynamic_array_raw_buffer(this->presentModes);");
            __c__("caps->alphaModeCount = hzstd_dynamic_array_size(this->alphaModes);");
            __c__("caps->alphaModes = hzstd_dynamic_array_raw_buffer(this->alphaModes);");
            return caps;
        }
    }
}

extern C const WGPU_DEPTH_SLICE_UNDEFINED: u32;

export struct RenderPassColorAttachment {
    view: mut TextureView | none = none;
    depthSlice: u32 | none = none;
    resolveTarget: mut TextureView | none = none;
    loadOp: LoadOp;
    storeOp: StoreOp;
    clearValue: Color;

    static fromFFI(conf: ffi.WGPURenderPassColorAttachment) {
        do unsafe {
            let c = RenderPassColorAttachment {
                view: none,
                depthSlice: WGPU_DEPTH_SLICE_UNDEFINED,
                resolveTarget: none,
                loadOp: LoadOpFromFFI(conf.loadOp),
                storeOp: StoreOpFromFFI(conf.storeOp),
                clearValue: {
                    r: conf.clearValue.r,
                    g: conf.clearValue.g,
                    b: conf.clearValue.b,
                    a: conf.clearValue.a,
                }
            };

            if conf.depthSlice != WGPU_DEPTH_SLICE_UNDEFINED {
                c.depthSlice = conf.depthSlice;
            }

            let tv = conf.view;
            if tv {
                c.view = TextureView { handle: tv };
            }

            let tvv = conf.resolveTarget;
            if tvv {
                c.resolveTarget = TextureView { handle: tvv };
            }

            return c;
        }
    }

    toInlineFFI() {
        do unsafe {
            let v = none as mut ffi.WGPUTextureViewImpl | none;
            let vv = this.view;
            if vv {
                v = vv.handle;
            }
            let r = none as mut ffi.WGPUTextureViewImpl | none;
            let rr = this.resolveTarget;
            if rr {
                r = rr.handle;
            }

            let ds = WGPU_DEPTH_SLICE_UNDEFINED;
            let dss = this.depthSlice;
            if dss {
                ds = dss;
            }

            let c = inline ffi.WGPURenderPassColorAttachment {
                nextInChain: none,
                depthSlice: ds,
                view: v,
                resolveTarget: r,
                loadOp: LoadOpToFFI(this.loadOp),
                storeOp: StoreOpToFFI(this.storeOp),
                clearValue: {
                    r: this.clearValue.r,
                    g: this.clearValue.g,
                    b: this.clearValue.b,
                    a: this.clearValue.a,
                }
            };
            return c;
        }
    }
}

export struct RequestAdapterOptions {
    featureLevel: FeatureLevel = FeatureLevel.Core;
    powerPreference: PowerPreference = PowerPreference.Undefined;
    forceFallbackAdapter: bool = false;
    backendType: BackendType = BackendType.Undefined;
    compatibleSurface: mut Surface | none = none;
}

export type RequestAdapterCallback = (status: RequestAdapterStatus, adapter: mut Adapter, message: str) => void :: final;
export struct RequestAdapterCallbackInfo {
    callback: RequestAdapterCallback;
    mode: CallbackMode = CallbackMode.WaitAnyOnly;
}

requestAdapterCallbackProxy(status: ffi.WGPURequestAdapterStatus, adapter: mut ffi.WGPUAdapterImpl, message: inline ffi.WGPUStringView, userdata1: cptr, userdata2: cptr): void :: final {
    do unsafe {
        let callback: RequestAdapterCallback = uninitialized;
        __c__("callback = (void*)userdata1;");
        callback(RequestAdapterStatusFromFFI(status), Adapter { handle: adapter }, viewToStr(message));
    }
}

export struct Instance {
    handle: mut ffi.WGPUInstanceImpl;

    requestAdapter(adapterOpts: RequestAdapterOptions | none, callbackInfo: RequestAdapterCallbackInfo) {

        let callback = callbackInfo.callback;
        let userdata1: cptr = none;
        __c__("userdata1 = (void*)callback;"); // Pass the function pointer to the highlevel callback into the lowlevel hook

        let ffiCallbackInfo = inline ffi.WGPURequestAdapterCallbackInfo {
            nextInChain: none,
            callback: requestAdapterCallbackProxy,
            mode: CallbackModeToFFI(callbackInfo.mode),
            userdata1: userdata1,
            userdata2: none,
        };

        if adapterOpts {
            let surface = adapterOpts.compatibleSurface;
            let compatibleSurface: mut ffi.WGPUSurfaceImpl | none = none;
            if surface {
                compatibleSurface = surface.handle;
            }

            return Future(
                ffi.wgpuInstanceRequestAdapter(this.handle, {
                    nextInChain: none,
                    featureLevel: FeatureLevelToFFI(adapterOpts.featureLevel),
                    powerPreference: PowerPreferenceToFFI(adapterOpts.powerPreference),
                    forceFallbackAdapter: adapterOpts.forceFallbackAdapter,
                    backendType: BackendTypeToFFI(adapterOpts.backendType),
                    compatibleSurface: compatibleSurface,
                }, ffiCallbackInfo)
            );
        }
        else {
            return Future(ffi.wgpuInstanceRequestAdapter(this.handle, none, ffiCallbackInfo));
        }
    }
}

export struct Limits {
    maxTextureDimension1D: u32 = 0;
    maxTextureDimension2D: u32 = 0;
    maxTextureDimension3D: u32 = 0;
    maxTextureArrayLayers: u32 = 0;
    maxBindGroups: u32 = 0;
    maxBindGroupsPlusVertexBuffers: u32 = 0;
    maxBindingsPerBindGroup: u32 = 0;
    maxDynamicUniformBuffersPerPipelineLayout: u32 = 0;
    maxDynamicStorageBuffersPerPipelineLayout: u32 = 0;
    maxSampledTexturesPerShaderStage: u32 = 0;
    maxSamplersPerShaderStage: u32 = 0;
    maxStorageBuffersPerShaderStage: u32 = 0;
    maxStorageTexturesPerShaderStage: u32 = 0;
    maxUniformBuffersPerShaderStage: u32 = 0;
    maxUniformBufferBindingSize: u64 = 0;
    maxStorageBufferBindingSize: u64 = 0;
    minUniformBufferOffsetAlignment: u32 = 0;
    minStorageBufferOffsetAlignment: u32 = 0;
    maxVertexBuffers: u32 = 0;
    maxBufferSize: u64 = 0;
    maxVertexAttributes: u32 = 0;
    maxVertexBufferArrayStride: u32 = 0;
    maxInterStageShaderVariables: u32 = 0;
    maxColorAttachments: u32 = 0;
    maxColorAttachmentBytesPerSample: u32 = 0;
    maxComputeWorkgroupStorageSize: u32 = 0;
    maxComputeInvocationsPerWorkgroup: u32 = 0;
    maxComputeWorkgroupSizeX: u32 = 0;
    maxComputeWorkgroupSizeY: u32 = 0;
    maxComputeWorkgroupSizeZ: u32 = 0;
    maxComputeWorkgroupsPerDimension: u32 = 0;

    toFFI() {
        return ffi.WGPULimits {
            nextInChain: none,
            maxTextureDimension1D: this.maxTextureDimension1D,
            maxTextureDimension2D: this.maxTextureDimension2D,
            maxTextureDimension3D: this.maxTextureDimension3D,
            maxTextureArrayLayers: this.maxTextureArrayLayers,
            maxBindGroups: this.maxBindGroups,
            maxBindGroupsPlusVertexBuffers: this.maxBindGroupsPlusVertexBuffers,
            maxBindingsPerBindGroup: this.maxBindingsPerBindGroup,
            maxDynamicUniformBuffersPerPipelineLayout: this.maxDynamicUniformBuffersPerPipelineLayout,
            maxDynamicStorageBuffersPerPipelineLayout: this.maxDynamicStorageBuffersPerPipelineLayout,
            maxSampledTexturesPerShaderStage: this.maxSampledTexturesPerShaderStage,
            maxSamplersPerShaderStage: this.maxSamplersPerShaderStage,
            maxStorageBuffersPerShaderStage: this.maxStorageBuffersPerShaderStage,
            maxStorageTexturesPerShaderStage: this.maxStorageTexturesPerShaderStage,
            maxUniformBuffersPerShaderStage: this.maxUniformBuffersPerShaderStage,
            maxUniformBufferBindingSize: this.maxUniformBufferBindingSize,
            maxStorageBufferBindingSize: this.maxStorageBufferBindingSize,
            minUniformBufferOffsetAlignment: this.minUniformBufferOffsetAlignment,
            minStorageBufferOffsetAlignment: this.minStorageBufferOffsetAlignment,
            maxVertexBuffers: this.maxVertexBuffers,
            maxBufferSize: this.maxBufferSize,
            maxVertexAttributes: this.maxVertexAttributes,
            maxVertexBufferArrayStride: this.maxVertexBufferArrayStride,
            maxInterStageShaderVariables: this.maxInterStageShaderVariables,
            maxColorAttachments: this.maxColorAttachments,
            maxColorAttachmentBytesPerSample: this.maxColorAttachmentBytesPerSample,
            maxComputeWorkgroupStorageSize: this.maxComputeWorkgroupStorageSize,
            maxComputeInvocationsPerWorkgroup: this.maxComputeInvocationsPerWorkgroup,
            maxComputeWorkgroupSizeX: this.maxComputeWorkgroupSizeX,
            maxComputeWorkgroupSizeY: this.maxComputeWorkgroupSizeY,
            maxComputeWorkgroupSizeZ: this.maxComputeWorkgroupSizeZ,
            maxComputeWorkgroupsPerDimension: this.maxComputeWorkgroupsPerDimension,
        };
    }
}

export struct QueueDescriptor {
    label: str = "";
}

export struct DeviceDescriptor {
    label: str = "";
    requiredFeatures: []FeatureName = []FeatureName {};
    requiredLimits: Limits | none = none;
    defaultQueue: QueueDescriptor = default;
    // deviceLostCallbackInfo: DeviceLostCallbackInfo | none;
    // uncapturedErrorCallbackInfo: inline WGPUUncapturedErrorCallbackInfo;
}

strToView(text: str) {
    do unsafe {
        let view: inline ffi.WGPUStringView = uninitialized;
        __c__("view.data = text.data;");
        __c__("view.length = text.length;");
        return view;
    }
}

viewToStr(view: inline ffi.WGPUStringView) {
    do unsafe {
        let text = "";
        __c__("text = hzstd_str_dup(HZSTD_STRING(view.data, view.length));");
        return text;
    }
}

export type RequestDeviceCallback = (status: RequestDeviceStatus, device: mut Device, message: str) => void :: final;
export struct RequestDeviceCallbackInfo {
    mode: CallbackMode = CallbackMode.WaitAnyOnly;
    callback: RequestDeviceCallback;
}

requestDeviceCallbackProxy(status: ffi.WGPURequestDeviceStatus, device: mut ffi.WGPUDeviceImpl, message: inline ffi.WGPUStringView, userdata1: cptr, userdata2: cptr): void :: final {
    do unsafe {
        let callback: RequestDeviceCallback = uninitialized;
        __c__("callback = (void*)userdata1;");
        callback(RequestDeviceStatusFromFFI(status), Device { handle: device }, viewToStr(message));
    }
}


export struct Adapter {
    handle: mut ffi.WGPUAdapterImpl;

    requestDevice(descriptor: DeviceDescriptor | none, callbackInfo: RequestDeviceCallbackInfo) {
        let ffiDescriptor: ffi.WGPUDeviceDescriptor | none = none;
        if descriptor {
            let requiredFeatureCount = 0 as usize;
            let requiredFeatures = none as cptr;

            let features = descriptor.requiredFeatures;
            __c__("requiredFeatureCount = hzstd_dynamic_array_size(features);");
            __c__("requiredFeatures = hzstd_dynamic_array_raw_buffer(features);");

            let limits = none as ffi.WGPULimits | none;
            let requiredLimits = descriptor.requiredLimits;
            if requiredLimits {
                limits = requiredLimits.toFFI();
            }

            do unsafe {
                let nullCallback = none as cptr;
                let nullCallback2: ffi.WGPUUncapturedErrorCallback = uninitialized;
                __c__("nullCallback2 = NULL;");

                let a: inline ffi.WGPUDeviceLostCallbackInfo = uninitialized;
                a.nextInChain = none;
                __c__("a.callback = NULL;");
                a.mode = ffi.WGPUCallbackMode_WaitAnyOnly;
                a.userdata1 = none;
                a.userdata2 = none;

                let b: inline ffi.WGPUUncapturedErrorCallbackInfo = uninitialized;
                b.nextInChain = none;
                __c__("a.callback = NULL;");
                b.userdata1 = none;
                b.userdata2 = none;

                ffiDescriptor = ffi.WGPUDeviceDescriptor {
                    nextInChain: none,
                    label: strToView(descriptor.label),
                    requiredFeatureCount: requiredFeatureCount,
                    requiredFeatures: requiredFeatures,
                    requiredLimits: limits,
                    defaultQueue: {
                        nextInChain: none,
                        label: strToView(descriptor.defaultQueue.label),
                    },
                    deviceLostCallbackInfo: a,
                    uncapturedErrorCallbackInfo: b,
                }
            }
        }

        let userdata1 = none as cptr;
        __c__("userdata1 = callbackInfo->callback;");

        let ffiCallbackInfo = inline ffi.WGPURequestDeviceCallbackInfo {
            nextInChain: none,
            mode: CallbackModeToFFI(callbackInfo.mode),
            callback: requestDeviceCallbackProxy,
            userdata1: userdata1,
            userdata2: none,
        };

        return Future(
            ffi.wgpuAdapterRequestDevice(this.handle, ffiDescriptor, ffiCallbackInfo)
        );
    }
}

export struct CommandEncoder {
    handle: mut ffi.WGPUCommandEncoderImpl;

    beginRenderPass(descriptor: RenderPassDescriptor): Result<RenderPassEncoder, none> {
        let handle = ffi.wgpuCommandEncoderBeginRenderPass(this.handle, descriptor.toFFI());
        if handle {
            return RenderPassEncoder {
                handle: handle,
            };
        }
    }

    finish(descriptor?: CommandBufferDescriptor): Result<CommandBuffer, none> {
        let d = none as ffi.WGPUCommandBufferDescriptor | none;
        if descriptor {
            d = descriptor.toFFI();
        }
        let buffer = ffi.wgpuCommandEncoderFinish(this.handle, d);
        if buffer {
            return CommandBuffer {
                handle: buffer,
            };
        }
    }
}

export struct Device {
    handle: mut ffi.WGPUDeviceImpl;

    getQueue(): Result<mut Queue, none> {
        const queue = ffi.wgpuDeviceGetQueue(this.handle);
        if queue {
            return Queue {
                handle: queue,
            };
        }
    }

    createCommandEncoder(descriptor?: CommandEncoderDescriptor): Result<CommandEncoder, none> {
        let d = none as ffi.WGPUCommandEncoderDescriptor | none;
        if descriptor {
            d = descriptor.toFFI();
        }
        let commandEncoder = ffi.wgpuDeviceCreateCommandEncoder(this.handle, d);
        if commandEncoder {
            return CommandEncoder {
                handle: commandEncoder,
            };
        }
    }
}

export struct Queue {
    handle: mut ffi.WGPUQueueImpl;

    submit(commands: []CommandBuffer) {
        let rawCommands = []ffi.WGPUCommandBufferImpl {};
        for (let i = 0; i < commands.length; i++) {
            rawCommands.push(commands[i].handle);
        }

        let len = 0 as usize;
        __c__("len = hzstd_dynamic_array_size(rawCommands);");

        let rawPtr = none as cptr;
        __c__("rawPtr = hzstd_dynamic_array_raw_buffer(rawCommands);");

        ffi.wgpuQueueSubmit(this.handle, len, rawPtr);
    }
}

export createInstance() { 
    let instance = ffi.wgpuCreateInstance({
        nextInChain: none,
        features: {
            nextInChain: none,
            timedWaitAnyEnable: false,
            timedWaitAnyMaxCount: 0,
        }
    });
    if instance {
        return Instance {
            handle: instance,
        };
    }
    return none;
}

export __c__("#include \"wgpu.h\"");
__c__("#include \"wgpu_impl.c\"");

export struct Future {
    id: u64;

    constructor(future: inline ffi.WGPUFuture): const Future {
        return {
            id: future.id,
        };
    }
}

export struct QuerySet {
    handle: mut ffi.WGPUQuerySetImpl;
}

extern C const WGPU_DEPTH_SLICE_UNDEFINED: u32;

export struct RequestAdapterOptions {
    featureLevel: FeatureLevel = FeatureLevel.Core;
    powerPreference: PowerPreference = PowerPreference.Undefined;
    forceFallbackAdapter: bool = false;
    backendType: BackendType = BackendType.Undefined;
    compatibleSurface: mut Surface | none = none;
}

export type RequestAdapterCallback = (status: RequestAdapterStatus, adapter: mut Adapter, message: str) => void :: final;
export struct RequestAdapterCallbackInfo {
    callback: RequestAdapterCallback;
    mode: CallbackMode = CallbackMode.WaitAnyOnly;
}

requestAdapterCallbackProxy(status: ffi.WGPURequestAdapterStatus, adapter: mut ffi.WGPUAdapterImpl, message: inline ffi.WGPUStringView, userdata1: cptr, userdata2: cptr): void :: final {
    do unsafe {
        let callback: RequestAdapterCallback = uninitialized;
        __c__("callback = (void*)userdata1;");
        callback(RequestAdapterStatusFromFFI(status), Adapter { handle: adapter }, fromFFI(message));
    }
}

export struct Instance {
    handle: mut ffi.WGPUInstanceImpl;

    requestAdapter(adapterOpts: RequestAdapterOptions | none, callbackInfo: RequestAdapterCallbackInfo) {

        let callback = callbackInfo.callback;
        let userdata1: cptr = none;
        __c__("userdata1 = (void*)callback;"); // Pass the function pointer to the highlevel callback into the lowlevel hook

        let ffiCallbackInfo = inline ffi.WGPURequestAdapterCallbackInfo {
            nextInChain: none,
            callback: requestAdapterCallbackProxy,
            mode: CallbackModeToFFI(callbackInfo.mode),
            userdata1: userdata1,
            userdata2: none,
        };

        if adapterOpts {
            let surface = adapterOpts.compatibleSurface;
            let compatibleSurface: mut ffi.WGPUSurfaceImpl | none = none;
            if surface {
                compatibleSurface = surface.handle;
            }

            return Future(
                ffi.wgpuInstanceRequestAdapter(this.handle, {
                    nextInChain: none,
                    featureLevel: FeatureLevelToFFI(adapterOpts.featureLevel),
                    powerPreference: PowerPreferenceToFFI(adapterOpts.powerPreference),
                    forceFallbackAdapter: adapterOpts.forceFallbackAdapter,
                    backendType: BackendTypeToFFI(adapterOpts.backendType),
                    compatibleSurface: compatibleSurface,
                }, ffiCallbackInfo)
            );
        }
        else {
            return Future(ffi.wgpuInstanceRequestAdapter(this.handle, none, ffiCallbackInfo));
        }
    }
}

export struct Limits {
    maxTextureDimension1D: u32 = 0;
    maxTextureDimension2D: u32 = 0;
    maxTextureDimension3D: u32 = 0;
    maxTextureArrayLayers: u32 = 0;
    maxBindGroups: u32 = 0;
    maxBindGroupsPlusVertexBuffers: u32 = 0;
    maxBindingsPerBindGroup: u32 = 0;
    maxDynamicUniformBuffersPerPipelineLayout: u32 = 0;
    maxDynamicStorageBuffersPerPipelineLayout: u32 = 0;
    maxSampledTexturesPerShaderStage: u32 = 0;
    maxSamplersPerShaderStage: u32 = 0;
    maxStorageBuffersPerShaderStage: u32 = 0;
    maxStorageTexturesPerShaderStage: u32 = 0;
    maxUniformBuffersPerShaderStage: u32 = 0;
    maxUniformBufferBindingSize: u64 = 0;
    maxStorageBufferBindingSize: u64 = 0;
    minUniformBufferOffsetAlignment: u32 = 0;
    minStorageBufferOffsetAlignment: u32 = 0;
    maxVertexBuffers: u32 = 0;
    maxBufferSize: u64 = 0;
    maxVertexAttributes: u32 = 0;
    maxVertexBufferArrayStride: u32 = 0;
    maxInterStageShaderVariables: u32 = 0;
    maxColorAttachments: u32 = 0;
    maxColorAttachmentBytesPerSample: u32 = 0;
    maxComputeWorkgroupStorageSize: u32 = 0;
    maxComputeInvocationsPerWorkgroup: u32 = 0;
    maxComputeWorkgroupSizeX: u32 = 0;
    maxComputeWorkgroupSizeY: u32 = 0;
    maxComputeWorkgroupSizeZ: u32 = 0;
    maxComputeWorkgroupsPerDimension: u32 = 0;

    toFFI() {
        return ffi.WGPULimits {
            nextInChain: none,
            maxTextureDimension1D: this.maxTextureDimension1D,
            maxTextureDimension2D: this.maxTextureDimension2D,
            maxTextureDimension3D: this.maxTextureDimension3D,
            maxTextureArrayLayers: this.maxTextureArrayLayers,
            maxBindGroups: this.maxBindGroups,
            maxBindGroupsPlusVertexBuffers: this.maxBindGroupsPlusVertexBuffers,
            maxBindingsPerBindGroup: this.maxBindingsPerBindGroup,
            maxDynamicUniformBuffersPerPipelineLayout: this.maxDynamicUniformBuffersPerPipelineLayout,
            maxDynamicStorageBuffersPerPipelineLayout: this.maxDynamicStorageBuffersPerPipelineLayout,
            maxSampledTexturesPerShaderStage: this.maxSampledTexturesPerShaderStage,
            maxSamplersPerShaderStage: this.maxSamplersPerShaderStage,
            maxStorageBuffersPerShaderStage: this.maxStorageBuffersPerShaderStage,
            maxStorageTexturesPerShaderStage: this.maxStorageTexturesPerShaderStage,
            maxUniformBuffersPerShaderStage: this.maxUniformBuffersPerShaderStage,
            maxUniformBufferBindingSize: this.maxUniformBufferBindingSize,
            maxStorageBufferBindingSize: this.maxStorageBufferBindingSize,
            minUniformBufferOffsetAlignment: this.minUniformBufferOffsetAlignment,
            minStorageBufferOffsetAlignment: this.minStorageBufferOffsetAlignment,
            maxVertexBuffers: this.maxVertexBuffers,
            maxBufferSize: this.maxBufferSize,
            maxVertexAttributes: this.maxVertexAttributes,
            maxVertexBufferArrayStride: this.maxVertexBufferArrayStride,
            maxInterStageShaderVariables: this.maxInterStageShaderVariables,
            maxColorAttachments: this.maxColorAttachments,
            maxColorAttachmentBytesPerSample: this.maxColorAttachmentBytesPerSample,
            maxComputeWorkgroupStorageSize: this.maxComputeWorkgroupStorageSize,
            maxComputeInvocationsPerWorkgroup: this.maxComputeInvocationsPerWorkgroup,
            maxComputeWorkgroupSizeX: this.maxComputeWorkgroupSizeX,
            maxComputeWorkgroupSizeY: this.maxComputeWorkgroupSizeY,
            maxComputeWorkgroupSizeZ: this.maxComputeWorkgroupSizeZ,
            maxComputeWorkgroupsPerDimension: this.maxComputeWorkgroupsPerDimension,
        };
    }
}

export struct QueueDescriptor {
    debugLabel?: str;
}

export struct DeviceDescriptor {
    debugLabel?: str;
    requiredFeatures: []FeatureName = []FeatureName {};
    requiredLimits: Limits | none = none;
    defaultQueue: QueueDescriptor = default;
    // deviceLostCallbackInfo: DeviceLostCallbackInfo | none;
    // uncapturedErrorCallbackInfo: inline WGPUUncapturedErrorCallbackInfo;
}

export type RequestDeviceCallback = (status: RequestDeviceStatus, device: mut Device, message: str) => void :: final;
export struct RequestDeviceCallbackInfo {
    mode: CallbackMode = CallbackMode.WaitAnyOnly;
    callback: RequestDeviceCallback;
}

requestDeviceCallbackProxy(status: ffi.WGPURequestDeviceStatus, device: mut ffi.WGPUDeviceImpl, message: inline ffi.WGPUStringView, userdata1: cptr, userdata2: cptr): void :: final {
    do unsafe {
        let callback: RequestDeviceCallback = uninitialized;
        __c__("callback = (void*)userdata1;");
        callback(RequestDeviceStatusFromFFI(status), Device { handle: device }, fromFFI(message));
    }
}


export struct Adapter {
    handle: mut ffi.WGPUAdapterImpl;

    requestDevice(descriptor: DeviceDescriptor | none, callbackInfo: RequestDeviceCallbackInfo) {
        let ffiDescriptor: ffi.WGPUDeviceDescriptor | none = none;
        if descriptor {
            let requiredFeatureCount = 0 as usize;
            let requiredFeatures = none as cptr;

            let features = descriptor.requiredFeatures;
            __c__("requiredFeatureCount = hzstd_dynamic_array_size(features);");
            __c__("requiredFeatures = hzstd_dynamic_array_raw_buffer(features);");

            let limits = none as ffi.WGPULimits | none;
            let requiredLimits = descriptor.requiredLimits;
            if requiredLimits {
                limits = requiredLimits.toFFI();
            }

            do unsafe {
                let nullCallback = none as cptr;
                let nullCallback2: ffi.WGPUUncapturedErrorCallback = uninitialized;
                __c__("nullCallback2 = NULL;");

                let a: inline ffi.WGPUDeviceLostCallbackInfo = uninitialized;
                a.nextInChain = none;
                __c__("a.callback = NULL;");
                a.mode = ffi.WGPUCallbackMode_WaitAnyOnly;
                a.userdata1 = none;
                a.userdata2 = none;

                let b: inline ffi.WGPUUncapturedErrorCallbackInfo = uninitialized;
                b.nextInChain = none;
                __c__("a.callback = NULL;");
                b.userdata1 = none;
                b.userdata2 = none;

                ffiDescriptor = ffi.WGPUDeviceDescriptor {
                    nextInChain: none,
                    label: toOptionalFFI(descriptor.debugLabel),
                    requiredFeatureCount: requiredFeatureCount,
                    requiredFeatures: requiredFeatures,
                    requiredLimits: limits,
                    defaultQueue: {
                        nextInChain: none,
                        label: toOptionalFFI(descriptor.defaultQueue.debugLabel),
                    },
                    deviceLostCallbackInfo: a,
                    uncapturedErrorCallbackInfo: b,
                }
            }
        }

        let userdata1 = none as cptr;
        __c__("userdata1 = callbackInfo->callback;");

        let ffiCallbackInfo = inline ffi.WGPURequestDeviceCallbackInfo {
            nextInChain: none,
            mode: CallbackModeToFFI(callbackInfo.mode),
            callback: requestDeviceCallbackProxy,
            userdata1: userdata1,
            userdata2: none,
        };

        return Future(
            ffi.wgpuAdapterRequestDevice(this.handle, ffiDescriptor, ffiCallbackInfo)
        );
    }
}

export createInstance() { 
    let instance = ffi.wgpuCreateInstance({
        nextInChain: none,
        features: {
            nextInChain: none,
            timedWaitAnyEnable: false,
            timedWaitAnyMaxCount: 0,
        }
    });
    if instance {
        return Instance {
            handle: instance,
        };
    }
    return none;
}

export struct RenderPassEncoder {
    handle: mut ffi.WGPURenderPassEncoderImpl;

    end() {
        ffi.wgpuRenderPassEncoderEnd(this.handle);
    }

    setPipeline(pipeline: mut RenderPipeline) {
        // export extern C noemit wgpuRenderPassEncoderSetPipeline(renderPassEncoder: mut WGPURenderPassEncoderImpl, pipeline: mut WGPURenderPipelineImpl): void :: final;
        ffi.wgpuRenderPassEncoderSetPipeline(this.handle, toFFI(pipeline));
    }

    setVertexBuffer(slot: u32, buffer: Buffer) {
        // export extern C noemit wgpuRenderPassEncoderSetVertexBuffer(renderPassEncoder: mut WGPURenderPassEncoderImpl, slot: u32, buffer: mut WGPUBufferImpl | none, offset: u64, size: u64): void :: final;
        let wholeSize = 0 as u64;
        __c__("wholeSize = WGPU_WHOLE_SIZE;");
        ffi.wgpuRenderPassEncoderSetVertexBuffer(this.handle, slot, toFFI(buffer), 0, wholeSize);
    }

    setIndexBuffer(buffer: Buffer, format: IndexFormat) {
        // export extern C noemit wgpuRenderPassEncoderSetIndexBuffer(renderPassEncoder: mut WGPURenderPassEncoderImpl, buffer: mut WGPUBufferImpl, format: WGPUIndexFormat, offset: u64, size: u64): void :: final;
        let wholeSize = 0 as u64;
        __c__("wholeSize = WGPU_WHOLE_SIZE;");
        ffi.wgpuRenderPassEncoderSetIndexBuffer(this.handle, toFFI(buffer), format, 0, wholeSize);
    }

    draw(vertexCount: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32) {
        // export extern C noemit wgpuRenderPassEncoderDraw(renderPassEncoder: mut WGPURenderPassEncoderImpl, vertexCount: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32): void :: final;
        ffi.wgpuRenderPassEncoderDraw(this.handle, vertexCount, instanceCount, firstVertex, firstInstance);
    }

    setViewport(x: real, y: real, width: real, height: real, minDepth: real, maxDepth: real) {
        // export extern C noemit wgpuRenderPassEncoderSetViewport(renderPassEncoder: mut WGPURenderPassEncoderImpl, x: f32, y: f32, width: f32, height: f32, minDepth: f32, maxDepth: f32): void :: final;
        ffi.wgpuRenderPassEncoderSetViewport(this.handle, x as f32, y as f32, width as f32, height as f32, minDepth as f32, maxDepth as f32);
    }

    setScissorRect(x: int, y: int, width: int, height: int) {
        // export extern C noemit wgpuRenderPassEncoderSetScissorRect(renderPassEncoder: mut WGPURenderPassEncoderImpl, x: u32, y: u32, width: u32, height: u32): void :: final;
        assert(x >= u32.min && x <= u32.max, "Scissor Rect x is out of bounds (x ∉ [u32.min, u32.max])");
        assert(y >= u32.min && y <= u32.max, "Scissor Rect y is out of bounds (y ∉ [u32.min, u32.max])");
        assert(width >= u32.min && width <= u32.max, "Scissor Rect width is out of bounds (width ∉ [u32.min, u32.max])");
        assert(height >= u32.min && height <= u32.max, "Scissor Rect height is out of bounds (height ∉ [u32.min, u32.max])");
        ffi.wgpuRenderPassEncoderSetScissorRect(this.handle, x, y, width, height);
    }
}

fromFFI(v: mut ffi.WGPURenderPassEncoderImpl): RenderPassEncoder :: final {
    return RenderPassEncoder {
        handle: v,
    };
}

toFFI(v: RenderPassEncoder): mut ffi.WGPURenderPassEncoderImpl :: final {
    return v.handle;
}

export struct RenderPassDescriptor {
    debugLabel?: str;
    colorAttachments: []RenderPassColorAttachment = {};
    depthStencilAttachment: RenderPassDepthStencilAttachment | none = none;
    occlusionQuerySet: mut QuerySet | none = none;
    timestampWrites: RenderPassTimestampWrites | none = none;
}

fromFFI(v: ffi.WGPURenderPassDescriptor): RenderPassDescriptor :: final {
    let c = RenderPassDescriptor {
        debugLabel: fromOptionalFFI(v.label),
        colorAttachments: {},
        depthStencilAttachment: none,
        occlusionQuerySet: none,
        timestampWrites: none,
    };

    for (let i = 0; i < v.colorAttachmentCount; i++) {
        do unsafe {
            let e: ffi.WGPURenderPassColorAttachment = uninitialized;
            __c__("e = &((WGPURenderPassColorAttachment*)v->colorAttachments)[i];");
            c.colorAttachments.push(fromFFI(e));
        }
    }

    do unsafe {
        let sa = none as ffi.WGPURenderPassDepthStencilAttachment | none;
        __c__("sa = (WGPURenderPassDepthStencilAttachment*)v->depthStencilAttachment;"); 
        if sa {
            c.depthStencilAttachment = fromFFI(sa);
        }
    }

    let oq = v.occlusionQuerySet;
    if oq {
        c.occlusionQuerySet = QuerySet { handle: oq };
    }

    do unsafe {
        let tw = none as ffi.WGPURenderPassTimestampWrites | none;
        __c__("tw = (WGPURenderPassTimestampWrites*)v->timestampWrites;"); 
        if tw {
            c.timestampWrites = fromFFI(tw);
        }
    }

    return c;
}

toFFI(v: RenderPassDescriptor): ffi.WGPURenderPassDescriptor :: final {
    do unsafe {
        let colorAttachmentArray = arrayToFFI<RenderPassColorAttachment, inline ffi.WGPURenderPassColorAttachment>(v.colorAttachments);
        return ffi.WGPURenderPassDescriptor {
            nextInChain: none,
            label: toOptionalFFI(v.debugLabel),
            colorAttachmentCount: colorAttachmentArray.length,
            colorAttachments: colorAttachmentArray.data,
            depthStencilAttachment: v.depthStencilAttachment ? toFFI(v.depthStencilAttachment) : none,
            occlusionQuerySet: v.occlusionQuerySet ? v.occlusionQuerySet.handle : none,
            timestampWrites: v.timestampWrites ? toFFI(v.timestampWrites) : none,
        };
    }
}

export struct RenderPassDepthStencilAttachment {
    view: mut TextureView;
    depthLoadOp: LoadOp;
    depthStoreOp: StoreOp;
    depthClearValue: f32;
    depthReadOnly: bool;
    stencilLoadOp: LoadOp;
    stencilStoreOp: StoreOp;
    stencilClearValue: u32;
    stencilReadOnly: bool;
}

fromFFI(v: ffi.WGPURenderPassDepthStencilAttachment): RenderPassDepthStencilAttachment :: final {
    return RenderPassDepthStencilAttachment {
        view: TextureView { handle: v.view },
        depthLoadOp: fromFFI(v.depthLoadOp),
        depthStoreOp: fromFFI(v.depthStoreOp),
        depthClearValue: v.depthClearValue,
        depthReadOnly: v.depthReadOnly,
        stencilLoadOp: fromFFI(v.stencilLoadOp),
        stencilStoreOp: fromFFI(v.stencilStoreOp),
        stencilClearValue: v.stencilClearValue,
        stencilReadOnly: v.stencilReadOnly,
    };
}

toFFI(v: RenderPassDepthStencilAttachment): ffi.WGPURenderPassDepthStencilAttachment :: final {
    return ffi.WGPURenderPassDepthStencilAttachment {
        view: v.view.handle,
        depthLoadOp: toFFI(v.depthLoadOp),
        depthStoreOp: toFFI(v.depthStoreOp),
        depthClearValue: v.depthClearValue,
        depthReadOnly: v.depthReadOnly,
        stencilLoadOp: toFFI(v.stencilLoadOp),
        stencilStoreOp: toFFI(v.stencilStoreOp),
        stencilClearValue: v.stencilClearValue,
        stencilReadOnly: v.stencilReadOnly,
    };
}

export struct RenderPassTimestampWrites {
    querySet: mut QuerySet;
    beginningOfPassWriteIndex: u32;
    endOfPassWriteIndex: u32;
}

fromFFI(v: ffi.WGPURenderPassTimestampWrites): RenderPassTimestampWrites :: final {
    return RenderPassTimestampWrites {
        querySet: QuerySet { handle: v.querySet },
        beginningOfPassWriteIndex: v.beginningOfPassWriteIndex,
        endOfPassWriteIndex: v.endOfPassWriteIndex,
    };
}

toFFI(v: RenderPassTimestampWrites): ffi.WGPURenderPassTimestampWrites :: final {
    return ffi.WGPURenderPassTimestampWrites {
        querySet: v.querySet.handle,
        beginningOfPassWriteIndex: v.beginningOfPassWriteIndex,
        endOfPassWriteIndex: v.endOfPassWriteIndex,
    };
}

export struct RenderPassColorAttachment {
    view: mut TextureView | none = none;
    depthSlice: u32 | none = none;
    resolveTarget: mut TextureView | none = none;
    loadOp: LoadOp;
    storeOp: StoreOp;
    clearValue: Color;
}

fromFFI(v: ffi.WGPURenderPassColorAttachment): RenderPassColorAttachment :: final {
    return RenderPassColorAttachment {
        view: v.view ? TextureView { handle: v.view } : none,
        depthSlice: v.depthSlice != WGPU_DEPTH_SLICE_UNDEFINED ? v.depthSlice : none,
        resolveTarget: v.resolveTarget ? TextureView { handle: v.resolveTarget } : none,
        loadOp: fromFFI(v.loadOp),
        storeOp: fromFFI(v.storeOp),
        clearValue: {
            r: v.clearValue.r,
            g: v.clearValue.g,
            b: v.clearValue.b,
            a: v.clearValue.a,
        }
    };
}

toFFI(v: RenderPassColorAttachment): ffi.WGPURenderPassColorAttachment :: final {
    return inline ffi.WGPURenderPassColorAttachment {
        nextInChain: none,
        view: v.view ? v.view.handle : none,
        depthSlice: v.depthSlice ? v.depthSlice : WGPU_DEPTH_SLICE_UNDEFINED,
        resolveTarget: v.resolveTarget ? v.resolveTarget.handle : none,
        loadOp: toFFI(v.loadOp),
        storeOp: toFFI(v.storeOp),
        clearValue: {
            r: v.clearValue.r,
            g: v.clearValue.g,
            b: v.clearValue.b,
            a: v.clearValue.a,
        }
    };
}

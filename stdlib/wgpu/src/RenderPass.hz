
export struct RenderPassEncoder {
    handle: mut ffi.WGPURenderPassEncoderImpl;

    end() {
        ffi.wgpuRenderPassEncoderEnd(this.handle);
    }
}

fromFFI(v: mut ffi.WGPURenderPassEncoderImpl): RenderPassEncoder :: final {
    return RenderPassEncoder {
        handle: v,
    };
}

toFFI(v: RenderPassEncoder): mut ffi.WGPURenderPassEncoderImpl :: final {
    return v.handle;
}

export struct RenderPassDescriptor {
    debugLabel?: str;
    colorAttachments: []RenderPassColorAttachment = {};
    depthStencilAttachment: RenderPassDepthStencilAttachment | none = none;
    occlusionQuerySet: mut QuerySet | none = none;
    timestampWrites: RenderPassTimestampWrites | none = none;
}

fromFFI(v: ffi.WGPURenderPassDescriptor): RenderPassDescriptor :: final {
    let c = RenderPassDescriptor {
        debugLabel: fromOptionalFFI(v.label),
        colorAttachments: {},
        depthStencilAttachment: none,
        occlusionQuerySet: none,
        timestampWrites: none,
    };

    for (let i = 0; i < v.colorAttachmentCount; i++) {
        do unsafe {
            let e: ffi.WGPURenderPassColorAttachment = uninitialized;
            __c__("e = &((WGPURenderPassColorAttachment*)v->colorAttachments)[i];");
            c.colorAttachments.push(fromFFI(e));
        }
    }

    do unsafe {
        let sa = none as ffi.WGPURenderPassDepthStencilAttachment | none;
        __c__("sa = (WGPURenderPassDepthStencilAttachment*)v->depthStencilAttachment;"); 
        if sa {
            c.depthStencilAttachment = fromFFI(sa);
        }
    }

    let oq = v.occlusionQuerySet;
    if oq {
        c.occlusionQuerySet = QuerySet { handle: oq };
    }

    do unsafe {
        let tw = none as ffi.WGPURenderPassTimestampWrites | none;
        __c__("tw = (WGPURenderPassTimestampWrites*)v->timestampWrites;"); 
        if tw {
            c.timestampWrites = fromFFI(tw);
        }
    }

    return c;
}

toFFI(v: RenderPassDescriptor): ffi.WGPURenderPassDescriptor :: final {
    do unsafe {
        let colorAttachmentArray = arrayToFFI<RenderPassColorAttachment, inline ffi.WGPURenderPassColorAttachment>(v.colorAttachments);
        return ffi.WGPURenderPassDescriptor {
            nextInChain: none,
            label: toOptionalFFI(v.debugLabel),
            colorAttachmentCount: colorAttachmentArray.length,
            colorAttachments: colorAttachmentArray.data,
            depthStencilAttachment: v.depthStencilAttachment ? toFFI(v.depthStencilAttachment) : none,
            occlusionQuerySet: v.occlusionQuerySet ? v.occlusionQuerySet.handle : none,
            timestampWrites: v.timestampWrites ? toFFI(v.timestampWrites) : none,
        };
    }
}

export struct RenderPassDepthStencilAttachment {
    view: mut TextureView;
    depthLoadOp: LoadOp;
    depthStoreOp: StoreOp;
    depthClearValue: f32;
    depthReadOnly: bool;
    stencilLoadOp: LoadOp;
    stencilStoreOp: StoreOp;
    stencilClearValue: u32;
    stencilReadOnly: bool;
}

fromFFI(v: ffi.WGPURenderPassDepthStencilAttachment): RenderPassDepthStencilAttachment :: final {
    return RenderPassDepthStencilAttachment {
        view: TextureView { handle: v.view },
        depthLoadOp: fromFFI(v.depthLoadOp),
        depthStoreOp: fromFFI(v.depthStoreOp),
        depthClearValue: v.depthClearValue,
        depthReadOnly: v.depthReadOnly,
        stencilLoadOp: fromFFI(v.stencilLoadOp),
        stencilStoreOp: fromFFI(v.stencilStoreOp),
        stencilClearValue: v.stencilClearValue,
        stencilReadOnly: v.stencilReadOnly,
    };
}

toFFI(v: RenderPassDepthStencilAttachment): ffi.WGPURenderPassDepthStencilAttachment :: final {
    return ffi.WGPURenderPassDepthStencilAttachment {
        view: v.view.handle,
        depthLoadOp: toFFI(v.depthLoadOp),
        depthStoreOp: toFFI(v.depthStoreOp),
        depthClearValue: v.depthClearValue,
        depthReadOnly: v.depthReadOnly,
        stencilLoadOp: toFFI(v.stencilLoadOp),
        stencilStoreOp: toFFI(v.stencilStoreOp),
        stencilClearValue: v.stencilClearValue,
        stencilReadOnly: v.stencilReadOnly,
    };
}

export struct RenderPassTimestampWrites {
    querySet: mut QuerySet;
    beginningOfPassWriteIndex: u32;
    endOfPassWriteIndex: u32;
}

fromFFI(v: ffi.WGPURenderPassTimestampWrites): RenderPassTimestampWrites :: final {
    return RenderPassTimestampWrites {
        querySet: QuerySet { handle: v.querySet },
        beginningOfPassWriteIndex: v.beginningOfPassWriteIndex,
        endOfPassWriteIndex: v.endOfPassWriteIndex,
    };
}

toFFI(v: RenderPassTimestampWrites): ffi.WGPURenderPassTimestampWrites :: final {
    return ffi.WGPURenderPassTimestampWrites {
        querySet: v.querySet.handle,
        beginningOfPassWriteIndex: v.beginningOfPassWriteIndex,
        endOfPassWriteIndex: v.endOfPassWriteIndex,
    };
}

export struct RenderPassColorAttachment {
    view: mut TextureView | none = none;
    depthSlice: u32 | none = none;
    resolveTarget: mut TextureView | none = none;
    loadOp: LoadOp;
    storeOp: StoreOp;
    clearValue: Color;
}

fromFFI(v: ffi.WGPURenderPassColorAttachment): RenderPassColorAttachment :: final {
    return RenderPassColorAttachment {
        view: v.view ? TextureView { handle: v.view } : none,
        depthSlice: v.depthSlice != WGPU_DEPTH_SLICE_UNDEFINED ? v.depthSlice : none,
        resolveTarget: v.resolveTarget ? TextureView { handle: v.resolveTarget } : none,
        loadOp: fromFFI(v.loadOp),
        storeOp: fromFFI(v.storeOp),
        clearValue: {
            r: v.clearValue.r,
            g: v.clearValue.g,
            b: v.clearValue.b,
            a: v.clearValue.a,
        }
    };
}

toFFI(v: RenderPassColorAttachment): ffi.WGPURenderPassColorAttachment :: final {
    return inline ffi.WGPURenderPassColorAttachment {
        nextInChain: none,
        view: v.view ? v.view.handle : none,
        depthSlice: v.depthSlice ? v.depthSlice : WGPU_DEPTH_SLICE_UNDEFINED,
        resolveTarget: v.resolveTarget ? v.resolveTarget.handle : none,
        loadOp: toFFI(v.loadOp),
        storeOp: toFFI(v.storeOp),
        clearValue: {
            r: v.clearValue.r,
            g: v.clearValue.g,
            b: v.clearValue.b,
            a: v.clearValue.a,
        }
    };
}

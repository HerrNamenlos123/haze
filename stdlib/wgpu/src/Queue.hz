

__c__("""
typedef struct {
    float x;
    float y;
} _ExpectedVec2f;

void debug_vec2f_layout(void* ptr, size_t count) {
    printf("=== Vec2f layout check ===\\n");
    printf("sizeof(Vec2f)   = %zu\\n", sizeof(_ExpectedVec2f));
    printf("alignof(Vec2f)  = %zu\\n", _Alignof(_ExpectedVec2f));
    printf("vertex count   = %zu\\n", count);

    float* f = (float*)ptr;
    for (size_t i = 0; i < count * 2; i++) {
        printf("f[%zu] = %f\\n", i, f[i]);
    }
}
""");

export struct Queue {
    handle: mut ffi.WGPUQueueImpl;

    submit(commands: []CommandBuffer) {
        let rawCommands = []ffi.WGPUCommandBufferImpl {};
        for (let i = 0; i < commands.length; i++) {
            rawCommands.push(commands[i].handle);
        }

        let len = 0 as usize;
        __c__("len = hzstd_dynamic_array_size(rawCommands);");

        let rawPtr = none as cptr;
        __c__("rawPtr = hzstd_dynamic_array_raw_buffer(rawCommands);");

        ffi.wgpuQueueSubmit(this.handle, len, rawPtr);
    }

    writeBuffer(buffer: mut Buffer, data: [](inline Vec2f)) {
        // export extern C noemit wgpuQueueWriteBuffer(queue: mut WGPUQueueImpl, buffer: mut WGPUBufferImpl, bufferOffset: u64, data: cptr, size: usize): void :: final;
        let elementSize = sizeof(type<inline Vec2f>);
        let raw = none as cptr;
        let count = 0 as usize;
        __c__("raw = hzstd_dynamic_array_raw_buffer(data);");
        __c__("count = hzstd_dynamic_array_size(data) * elementSize;")
        __c__("debug_vec2f_layout(raw, hzstd_dynamic_array_size(data));");
        ffi.wgpuQueueWriteBuffer(this.handle, buffer.handle, 0, raw, count);
    }
}

fromFFI(v: mut ffi.WGPUQueueImpl): mut Queue :: final {
    return Queue {
        handle: v,
    };
}

toFFI(v: Queue): mut ffi.WGPUQueueImpl :: final {
    return v.handle;
}

export struct Queue {
    handle: mut ffi.WGPUQueueImpl;

    submit(commands: []CommandBuffer) {
        let rawCommands: []ffi.WGPUCommandBufferImpl = [];
        for (let i = 0; i < commands.length; i++) {
            rawCommands.push(commands[i].handle);
        }

        let len = 0 as usize;
        __c__("len = hzstd_dynamic_array_size(rawCommands);");

        let rawPtr = none as cptr;
        __c__("rawPtr = hzstd_dynamic_array_raw_buffer(rawCommands);");

        ffi.wgpuQueueSubmit(this.handle, len, rawPtr);
    }

    writeBuffer<T>(buffer: mut Buffer, data: []T) {
        // export extern C noemit wgpuQueueWriteBuffer(queue: mut WGPUQueueImpl, buffer: mut WGPUBufferImpl, bufferOffset: u64, data: cptr, size: usize): void :: final;
        let elementSize = sizeof(T);
        let raw = none as cptr;
        let count = 0 as usize;
        __c__("raw = hzstd_dynamic_array_raw_buffer(data);");
        __c__("count = hzstd_dynamic_array_size(data) * elementSize;")

        // __c__("""
        //     printf("Number of Shapes: %d\\n", hzstd_dynamic_array_size(data));
        //     for (int i = 0; i < hzstd_dynamic_array_size(data); i++) {
        //         float* floats = (float*)(raw + i * elementSize);
        //         printf("Shape #%d:\\n", i + 1);
        //         printf("Pos: %f %f\\n", floats[0], floats[1]);
        //         printf("Size: %f %f\\n", floats[2], floats[3]);
        //         printf("Radius: %f\\n", floats[4]);
        //         printf("Border Thickness: %f\\n", floats[5]);
        //         printf("Fill Color: %f %f %f %f\\n", floats[6], floats[7], floats[8], floats[9]);
        //         printf("Border Color: %f %f %f %f\\n", floats[10], floats[11], floats[12], floats[13]);
        //         printf("Type: %u\\n", ((uint32_t*)raw)[14]);
        //     }
        // """);

        ffi.wgpuQueueWriteBuffer(this.handle, buffer.handle, 0, raw, count);
    }
}

fromFFI(v: mut ffi.WGPUQueueImpl): mut Queue :: final {
    return Queue {
        handle: v,
    };
}

toFFI(v: Queue): mut ffi.WGPUQueueImpl :: final {
    return v.handle;
}

export struct Queue {
    handle: mut ffi.WGPUQueueImpl;

    submit(commands: []CommandBuffer) {
        let rawCommands = []ffi.WGPUCommandBufferImpl {};
        for (let i = 0; i < commands.length; i++) {
            rawCommands.push(commands[i].handle);
        }

        let len = 0 as usize;
        __c__("len = hzstd_dynamic_array_size(rawCommands);");

        let rawPtr = none as cptr;
        __c__("rawPtr = hzstd_dynamic_array_raw_buffer(rawCommands);");

        ffi.wgpuQueueSubmit(this.handle, len, rawPtr);
    }

    writeBuffer(buffer: mut Buffer, data: [](inline Vec2f)) {
        // export extern C noemit wgpuQueueWriteBuffer(queue: mut WGPUQueueImpl, buffer: mut WGPUBufferImpl, bufferOffset: u64, data: cptr, size: usize): void :: final;
        let elementSize = sizeof(type<inline Vec2f>);
        let raw = none as cptr;
        let count = 0 as usize;
        __c__("raw = hzstd_dynamic_array_raw_buffer(data);");
        __c__("count = hzstd_dynamic_array_size(data) * elementSize;")
        ffi.wgpuQueueWriteBuffer(this.handle, buffer.handle, 0, raw, count);
    }
}

fromFFI(v: mut ffi.WGPUQueueImpl): mut Queue :: final {
    return Queue {
        handle: v,
    };
}

toFFI(v: Queue): mut ffi.WGPUQueueImpl :: final {
    return v.handle;
}
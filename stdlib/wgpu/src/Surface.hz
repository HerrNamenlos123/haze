
export struct Surface {
    handle: mut ffi.WGPUSurfaceImpl;

    getCapabilities(adapter: mut Adapter): Result<SurfaceCapabilities, none> {
        do unsafe {
            let caps = ffi.WGPUSurfaceCapabilities {
                nextInChain: none,
                usages: 0,
                formatCount: 0,
                formats: none,
                presentModeCount: 0,
                presentModes: none,
                alphaModeCount: 0,
                alphaModes: none,
            };
            let status = ffi.wgpuSurfaceGetCapabilities(this.handle, adapter.handle, caps);
            if status != ffi.WGPUStatus_Success {
                return none;
            }
            return fromFFI(caps);
        }
    }

    configure(config: SurfaceConfiguration) {
        ffi.wgpuSurfaceConfigure(this.handle, toFFI(config));
    }

    getCurrentTexture() {
        let texture = ffi.WGPUSurfaceTexture {
            nextInChain: none,
            texture: none,
            status: ffi.WGPUSurfaceGetCurrentTextureStatus_SuccessOptimal, // will be overwritten
        };
        ffi.wgpuSurfaceGetCurrentTexture(this.handle, texture);
        return fromFFI(texture);
    }

    present(): Result<none, none> {
        let status = ffi.wgpuSurfacePresent(this.handle);
        if status == ffi.WGPUStatus_Success {
            return Result<none, none>.Ok(none);
        }
        return Result<none, none>.Err(none);
    }
}

export struct SurfaceTexture {
    texture: mut Texture | none;
    status: SurfaceGetCurrentTextureStatus;
}

fromFFI(v: ffi.WGPUSurfaceTexture): SurfaceTexture :: final {
    return SurfaceTexture {
        texture: v.texture ? fromFFI(v.texture) : none,
        status: fromFFI(v.status),
    };
}

toFFI(v: SurfaceTexture): ffi.WGPUSurfaceTexture :: final {
    return ffi.WGPUSurfaceTexture {
        nextInChain: none,
        texture: v.texture ? toFFI(v.texture) : none,
        status: toFFI(v.status),
    };
}

export struct SurfaceConfiguration {
    format: TextureFormat = TextureFormat.Undefined;
    usage: TextureUsage = TextureUsage.None;
    width: int = 0;
    height: int = 0;
    viewFormats: []TextureFormat = [];
    alphaMode: CompositeAlphaMode = CompositeAlphaMode.Auto;
    presentMode: PresentMode = PresentMode.Undefined;
    device: mut Device;
}

fromFFI(v: ffi.WGPUSurfaceConfiguration): SurfaceConfiguration :: final {
    let c = SurfaceConfiguration {
        device: Device { handle: v.device },
        format: fromFFI(v.format),
        usage: textureUsageFromFFI(v.usage),
        width: v.width,
        height: v.height,
        viewFormats: [],
        alphaMode: fromFFI(v.alphaMode),
        presentMode: fromFFI(v.presentMode),
    };

    for (let i = 0; i < v.viewFormatCount; i++) {
        do unsafe {
            let e: TextureFormat = uninitialized;
            __c__("e = (int)((WGPUTextureFormat*)v->viewFormats)[i];");
            c.viewFormats.push(e);
        }
    }

    return c;
}

toFFI(v: SurfaceConfiguration): ffi.WGPUSurfaceConfiguration :: final {
    assert(v.width >= u32.min && v.width <= u32.max, "Surface Width is out of bounds (v.width ∉ [u32.min, u32.max])");
    assert(v.height >= u32.min && v.height <= u32.max, "Surface Height is out of bounds (v.height ∉ [u32.min, u32.max])");
    let viewFormats = arrayToFFI<TextureFormat, ffi.WGPUTextureFormat>(v.viewFormats);
    return ffi.WGPUSurfaceConfiguration {
        nextInChain: none,
        device: v.device.handle,
        format: toFFI(v.format),
        usage: toFFI(v.usage),
        width: v.width,
        height: v.height,
        viewFormatCount: viewFormats.length,
        viewFormats: viewFormats.data,
        alphaMode: toFFI(v.alphaMode),
        presentMode: toFFI(v.presentMode),
    };
}

export struct SurfaceCapabilities {
    usages: TextureUsage = TextureUsage.None;
    formats: []TextureFormat = [];
    presentModes: []PresentMode = [];
    alphaModes: []CompositeAlphaMode = [];
}

fromFFI(v: ffi.WGPUSurfaceCapabilities): SurfaceCapabilities :: final {
    do unsafe {
        let c = SurfaceCapabilities {
            usages: textureUsageFromFFI(v.usages),
        };

        for (let i = 0; i < v.formatCount; i++) {
            do unsafe {
                let e: TextureFormat = uninitialized;
                __c__("e = (int)((WGPUTextureFormat*)v->formats)[i];");
                c.formats.push(e);
            }
        }

        for (let i = 0; i < v.presentModeCount; i++) {
            do unsafe {
                let p: PresentMode = uninitialized;
                __c__("p = (int)((WGPUPresentMode*)v->presentModes)[i];");
                c.presentModes.push(p);
            }
        }

        for (let i = 0; i < v.alphaModeCount; i++) {
            do unsafe {
                let a: CompositeAlphaMode = uninitialized;
                __c__("a = (int)((WGPUCompositeAlphaMode*)v->alphaModes)[i];");
                c.alphaModes.push(a);
            }
        }

        return c;
    }
}

toFFI(v: SurfaceCapabilities): ffi.WGPUSurfaceCapabilities :: final {
    let formats = arrayToFFI<TextureFormat, ffi.WGPUTextureFormat>(v.formats);
    let presentModes = arrayToFFI<PresentMode, ffi.WGPUPresentMode>(v.presentModes);
    let alphaModes = arrayToFFI<CompositeAlphaMode, ffi.WGPUCompositeAlphaMode>(v.alphaModes);
    return ffi.WGPUSurfaceCapabilities {
        nextInChain: none,
        usages: toFFI(v.usages),
        formatCount: formats.length,
        formats: formats.data,
        presentModeCount: presentModes.length,
        presentModes: presentModes.data,
        alphaModeCount: alphaModes.length,
        alphaModes: alphaModes.data,
    };
}

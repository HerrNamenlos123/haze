
struct EnumValue {
    name: str = "";
    value: str = ""; // Hexadecimal string
}

struct EnumResult {
    name: str = "";
    values: []EnumValue = {};
}

extractEnums(file: str): Result<[]EnumResult, str> {
    attempt {
        // Remove all comments to avoid accidental matches
        let stripped = regex.replace(r"\/\/[^\n\r]*|\/\*[\s\S]*?\*\/", file, "");

        // Get loose baseline enum number to make sure we are not missing some weird inconsistent enums
        let baselineEnums = regex.findAll(r"enum\s+(?:\w+\s*)?\{[\s\S]*?\}", stripped);

        // Now get them using the strictly matching structure
        let enumDefinitions = regex.findAll(r"(?:typedef\s+)?enum\s+(?:(\w+)\s*)?\{([\s\S]*?)\}\s*(\w+)?\s*", stripped);
        assert(enumDefinitions.length == baselineEnums.length);

        let results = []EnumResult {};
        for (let i = 0; i < enumDefinitions.length; i++) {
            assert(enumDefinitions[i].groups.length == 3);

            let result = EnumResult {
                name: enumDefinitions[i].groups[2].text,
            };

            let enumerators = regex.findAll(r"(\w+)\s*(?:=\s*([^,}]+))?\s*,?", enumDefinitions[i].groups[1].text);
            for (let j = 0; j < enumerators.length; j++) {
                let values = regex.find(r"^\s*(\w+)\s*(?:=\s*(.+?))?\s*,?\s*$", enumerators[j].text);
                if !values { raise "Values in enum not found"; }
                assert(values.groups.length == 2);
                let enumeratorValue = values.groups[1].text;
                assert(regex.match(r"^0[xX][0-9a-fA-F]+$", enumeratorValue));
                result.values.push({
                    name: values.groups[0].text,
                    value: enumeratorValue,
                })
            }
            results.push(result);
        }

        return results;
    }
    else e {
        if e is fs.Error {
            return fmt.format(e);
        }
        else if e is str {
            return fmt.format(e);
        }
        else if e is int {
            return fmt.format(e);
        }
        assert(false);
    }
}

struct GenArgs {
    outfile: str;
    enums: []EnumResult;
}

generateBindings(args: GenArgs) {
    let file = "";
    file = file + "A";
    fs.writeFile(args.outfile, file)?!;
}

fooz() {
    if (false) {
        return 5;
    }
}

generate(): int {
    attempt {
        let binaryDir = env.get("HAZE_MODULE_BINARY_DIR");
        if !binaryDir { raise f"HAZE_MODULE_BINARY_DIR not defined"; }

        let tempDir = env.get("HAZE_MODULE_TMP_DIR");
        if !tempDir { raise f"HAZE_MODULE_TMP_DIR not defined"; }

        let workspaceDir = env.get("HAZE_WORKSPACE_DIR");
        if !workspaceDir { raise f"HAZE_WORKSPACE_DIR not defined"; }

        let filepath = f"{workspaceDir}/wgpu/bin/include/webgpu.h";
        let file = fs.readFile(filepath)?!;
        let enums = extractEnums(file)?!;

        generateBindings({
            outfile: f"{binaryDir}/autogen/webgpu.hz",
            enums: enums,
        });
    }
    else e {
        if e is fs.Error {
            fmt.println(f"build-wgpu step failed: {e}");
            return 1;
        }
        else if e is str {
            fmt.println(f"build-wgpu step failed: {e}");
            return 1;
        }
        assert(false);
    }
    return 0;
}

main(): int {
    return generate();
}
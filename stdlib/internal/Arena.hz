
inject "#include <stdarg.h>";
inject "#include <stdlib.h>";
inject "#include <stdio.h>";
inject "#include <math.h>";
inject "#include <time.h>";
inject "#include <assert.h>";
inject "#include <memory.h>";

extern "C" noemit calloc(num: u64, size: u64): none*;
extern "C" noemit realloc(ptr: none*, newSize: u64): none*;
extern "C" noemit free(ptr: none*);
extern "C" noemit memcpy(to: none*, from: none*, length: u64): none*;

extern "C" noemit printf(fmt: str, ...): none;
extern "C" noemit abort();
extern "C" noemit assert(cond: boolean);

export struct Arena {
  head: Chunk*;

  constructor(): Arena {
    return Arena { head: 0 as Chunk* };
  }

  alloc<T>(value: T): T* {
    const t = this.allocate_raw(sizeof<T>);
    *t = value;
    return t;
  }

  allocate_raw(size: u64): none* {
    let current = this.head;

    while current != 0 as Chunk* {
      if (*current).hasSpace(size) {
        return (*current).alloc(size) as none*;
      }
      current = current.next;
    }

    // No space in existing chunks â€” create a new one
    let chunk_size = Internal.max<u64>(this.getChunkSize(), size);
    let memory = Internal.system_alloc_zeroed(chunk_size);  // zeroed malloc
    let new_chunk = Internal.heap_alloc<Chunk>(Chunk {
      memory: memory,
      offset: 0 as u64,
      capacity: chunk_size,
      next: this.head
    });

    let ptr = (*new_chunk).alloc(size);
    this.head = new_chunk;
    return ptr as none*;
  }

  free() {
    let current = this.head;
    while current != 0 as Chunk* {
      Internal.system_free(current.memory as none*);
      let next = current.next;
      Internal.heap_free<Chunk>(current);  // if you allocate the chunk itself
      current = next;
    }
    this.head = 0 as Chunk*;
  }

  struct Chunk {
    memory: u8*;
    offset: u64;
    capacity: u64;
    next: Chunk*;

    hasSpace(size: u64): boolean {
      return this.offset + size <= this.capacity;
    }

    alloc(size: u64): u8* {
      let ptr = this.memory + this.offset;
      this.offset += size;
      return ptr;
    }
  }

  getChunkSize(): u64 {
    const CHUNK_SIZE = 4096; // Need better support for global variables
    return CHUNK_SIZE as u64;
  }

    // TODO: Allow namespace inside struct
  struct Internal {
    static max<T>(a: T, b: T): T {
        if (a > b) {
            return a;
        }
        else {
            return b;
        }
    }

    static system_alloc_zeroed(size: u64): u8* {
        return calloc(size, 1 as u64) as u8*;
    }

    static heap_alloc<T>(value: T): T* {
        let size = sizeof<T>;
        let ptr = Internal.system_alloc_zeroed(size);  // could be malloc/calloc
        const t = ptr as T*;
        *t = value;
        return t;
    }

    static heap_free<T>(ptr: T*) {
        Internal.system_free(ptr as none*);
    }

    static system_free(ptr: none*) {
        free(ptr);
    }
  }
}
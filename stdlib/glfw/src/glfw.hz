
__c__("#define GLFW_INCLUDE_NONE");
__c__("#include <GLFW/glfw3.h>");
__c__("#include <math.h>");
__c__("#include <string.h>");

extern C noemit strcmp(str1: ccstr, str2: ccstr): i32 :: final;
extern C noemit getenv(name: ccstr): ccstr :: final;

const GLFW_PLATFORM: i32;
const GLFW_PLATFORM_X11: i32;
const GLFW_ANY_PLATFORM: i32;
const GLFW_CONTEXT_VERSION_MAJOR: i32;
const GLFW_CONTEXT_VERSION_MINOR: i32;
const GLFW_OPENGL_PROFILE: i32;
const GLFW_OPENGL_CORE_PROFILE: i32;
const GLFW_CLIENT_API: i32;
const GLFW_NO_API: i32;

namespace ffi {
    export extern C struct GLFWwindow {};
    export extern C struct GLFWmonitor {};

    extern C glfwInit(): i32 :: final;
    extern C glfwTerminate(): void :: final;
    extern C glfwCreateWindow(width: i32, height: i32, title: ccstr, monitor?: GLFWmonitor, share?: GLFWwindow): GLFWwindow | none :: final;
    extern C glfwDestroyWindow(w: GLFWwindow) :: final;
    extern C glfwWindowShouldClose(w: GLFWwindow): i32 :: final;
    extern C glfwSetWindowShouldClose(w: GLFWwindow, value: i32) :: final;
    extern C glfwSwapBuffers(w: GLFWwindow) :: final;
    extern C glfwSwapInterval(flag: i32) :: final;
    extern C glfwMakeContextCurrent(w: GLFWwindow) :: final;
    extern C glfwPollEvents() :: final;
    extern C glfwInitHint(hint: i32, value: i32) :: final;
    extern C glfwWindowHint(hint: i32, value: i32) :: final;
    extern C glfwGetTime(): f64 :: final;
    // extern C glfwMakeContextCurrent(w: GLFWwindow*);
    extern C glfwGetProcAddress(procname: ccstr): (() => void) :: final;

    // extern C glfwCreateWindowWGPUSurface(instance: inline WGPUInstance, w: GLFWwindow): inline WGPUSurface :: final;

    // export extern C glfwCreateWindowWGPUSurface_impl(instance: inline WGPUInstance, w: GLFWwindow) {
    //     return glfwCreateWindowWGPUSurface(instance, w);
    // }

    export init(): bool {
        return glfwInit() != 0;
    }

    export terminate(): void {
        glfwTerminate();
    }

    export createWindow(width: i32, height: i32, title: ccstr, monitor?: GLFWmonitor, share?: GLFWwindow): GLFWwindow | none {
        return glfwCreateWindow(width, height, title, monitor, share);
    }

    export windowShouldClose(w: GLFWwindow): bool {
        return glfwWindowShouldClose(w) != 0;
    }

    export setWindowShouldClose(w: GLFWwindow, value: bool) {
        if value == true {
            glfwSetWindowShouldClose(w, 1);
        }
        else {
            glfwSetWindowShouldClose(w, 0);
        }
    }

    export swapBuffers(w: GLFWwindow) {
        glfwSwapBuffers(w);
    }

    export swapInterval(flags: i32) {
        glfwSwapInterval(flags);
    }

    export destroyWindow(w: GLFWwindow) {
        glfwDestroyWindow(w);
    }

    export makeContextCurrent(w: GLFWwindow) {
        glfwMakeContextCurrent(w);
    }

    export pollEvents() {
        glfwPollEvents();
    }

    export initHint(hint: i32, value: i32) {
        glfwInitHint(hint, value);
    }

    export windowHint(hint: i32, value: i32) {
        glfwWindowHint(hint, value);
    }

    export getTime(): f64 {
        return glfwGetTime() as f64;
    }

    export extern C glfw_getProcAddress(procname: ccstr): () => void {
        return glfwGetProcAddress(procname);
    }
}

export struct Window {
    handle: ffi.GLFWwindow;

    makeContextCurrent() {
        ffi.makeContextCurrent(this.handle);
    }

    shouldClose(): bool {
        return ffi.windowShouldClose(this.handle);
    }

    close() {
        ffi.setWindowShouldClose(this.handle, true);
    }

    destroy() {
        ffi.destroyWindow(this.handle);
    }

    swapBuffers() {
        ffi.makeContextCurrent(this.handle);
        ffi.swapBuffers(this.handle);
    }

    swapInterval(interval: int) {
        if interval >= 0 && interval <= 10 {
            ffi.makeContextCurrent(this.handle);
            ffi.swapInterval(interval as i32);
        }
    }

    getProcAddress(): (name: ccstr) => cptr {
        // This makeContextCurrent() is important because getProcAddress is usually immediately passed to
        // gl.init, which then takes the GL context. It is important that the two are linked.
        // We just need to hope someone doesn't call getProcAddress and then do something else instead of gl.init()
        this.makeContextCurrent(); 

        do unsafe {
            const rawProc = ffi.glfw_getProcAddress;
            const castedProc: (name: ccstr) => cptr = uninitialized;
            __c__("castedProc = (void*)rawProc;");
            return castedProc;
        }
    }
}

export struct WindowSizeConfig {
    width: int = 1080;
    height: int = 720;
}

export struct WindowConfig {
    title: ccstr;
    size: WindowSizeConfig = {};
    noApi: bool = false; // This prevents graphics context creation, which is required for Vulkan
}

export init(): bool {
    const desktop = getenv("XDG_CURRENT_DESKTOP");
    let valid = true;
    __c__("valid = desktop != 0;");
    if (valid && strcmp(desktop, "GNOME") == 0) {
        ffi.initHint(GLFW_PLATFORM, GLFW_PLATFORM_X11);
    }
    else {
        ffi.initHint(GLFW_PLATFORM, GLFW_ANY_PLATFORM);
    }
    return ffi.init();
}

export terminate() {
    ffi.terminate();
}

export createWindow(config: WindowConfig): Window | none {
    ffi.windowHint(GLFW_CONTEXT_VERSION_MAJOR, 3 as i32);
    ffi.windowHint(GLFW_CONTEXT_VERSION_MINOR, 3 as i32);
    ffi.windowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    if (config.noApi) {
        ffi.windowHint(GLFW_CLIENT_API, GLFW_NO_API);
    }

    const width = config.size.width;
    const height = config.size.height;
    const widthI32: i32 = 0;
    const heightI32: i32 = 0;
    if (width >= i32.min && width <= i32.max) {
        widthI32 = width;
    }
    else {
        assert(false, "FAIL");
    }
    if (height >= i32.min && height <= i32.max) {
        heightI32 = height;
    }
    const handle = ffi.createWindow(widthI32, heightI32, config.title, none, none);
    if handle {
        return Window { handle: handle };
    }
    return none;
}

export pollEvents() {
    ffi.pollEvents();
}

export getTime(): real {
    return ffi.getTime() as real;
}
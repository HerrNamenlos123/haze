// ============================================================================
// HAZE GENERICS / NESTING / NAME-RESOLUTION MEGA STRESS
// Focus: deep nesting, partial refs, generic shadowing, forward refs,
//        sibling vs parent lookup, and qualification merging across levels.
// ============================================================================

// --- File: ds/collections.hz -------------------------------------------------
namespace DS {
  struct Map<K> {
    struct Entry<V> { key: K; value: V; }

    // Nested type that itself nests another type
    struct Bucket<Ix> {
      struct Cell<T> { idx: Ix; payload: T; }
    }

    // Return type uses parent (K) + its own (V) + nested child (Ix/T)
    // Partial references on both levels.
    make_cell<V, Ix, T>(self: Map<K>, k: K, v: V, ix: Ix, t: T): Bucket<Ix>.Cell<T> {
      // let c: Bucket<Ix>.Cell<T> = Bucket<Ix>.Cell<T>{ idx: ix, payload: t };
      // return c;
    }
  }

  // Shadowing test: generic name inside child shadows parent's name.
  struct Shadow<P> {
    struct Child<P> { // shadows parent P
      pair(a: P, b: P): P { return a; }
    }

    // return type refers to Child<P> where P is the *child's* P, not outer
    use_shadow<P>(self: Shadow<P>, a: P, b: P): Child<P> {
      // let _ = Child<P>{}; // construct something to force resolution
      // return _;
    }
  }
}

// --- File: model/graph.hz ----------------------------------------------------
namespace Graph {
  struct Graph<N> {
    struct Edge<W> { from: N; to: N; w: W; }

    // Multi-level nested types with reuse of names
    struct Layers<L> {
      struct Node<ID> {
        id: ID;
        data: L;
      }

      // Method returning a child-of-child type using *partial* references.
      mkNode<ID>(self: Layers<L>, id: ID, data: L): Node<ID> {
        // return Node<ID>{ id: id, data: data };
      }

      // Deep child referencing grandparent's generic N via the outer Graph<N>
      struct Binder {
        bind<N2>(self: Binder, n: N2, l: L): Node<N2> {
          // return Node<N2>{ id: n, data: l };
        }
      }
    }

    // Method that returns a child type of a child type,
    // requiring parent context merge: Layers<L>.Node<ID>.
    mkLayerNode<L, ID>(self: Graph<N>, id: ID, data: L): Layers<L>.Node<ID> {
      // let node: Layers<L>.Node<ID> = Layers<L>.Node<ID>{ id: id, data: data };
      // return node;
    }

    // Method that returns Edge<W> using own N + method W.
    mkEdge<W>(self: Graph<N>, a: N, b: N, w: W): Edge<W> {
      // return Edge<W>{ from: a, to: b, w: w };
    }
  }

  // Forward ref across lexical order inside namespace
  area_poly<W>(g: Graph<W>.Edge<W>): i32 {
    // dummy
    return 0;
  }
}

// --- File: algebra/monoids.hz -----------------------------------------------
namespace Algebra {
  // Monoid<M> with nested Op<T>, and an Adapter<Z> that re-uses parent generics.
  struct Monoid<M> {
    struct Op<T> { left: T; right: T; }

    struct Adapter<Z> {
      apply<T>(self: Adapter<Z>, a: T, b: T): Op<T> {
        // return Op<T>{ left: a, right: b };
      }
    }

    // Method that returns nested-nested type: Adapter<Z>.apply produces Op<T>
    use<Z, T>(self: Monoid<M>, a: T, b: T): Op<T> {
      // let ad: Adapter<Z> = Adapter<Z>{};
      // return ad.apply<T>(a, b);
    }
  }

  // Shadowing across levels: inner struct uses same name as outer generic
  struct Shadow<S> {
    struct S<T> { v: T; } // name S shadows type param S in this scope

    build<T>(self: Shadow<S>, x: T): S<T> {
      // return S<T>{ v: x };
    }
  }
}

// --- File: nested/tower.hz ---------------------------------------------------
namespace Tower {
  // A 3-level tower with heavy cross-referencing
  struct A<A0> {
    struct B<B0> {
      struct C<C0> {
        aa: A0; bb: B0; cc: C0;

        // Returns parent’s sibling’s child type: B<B0>.C<C0>
        echo(self: C<C0>, a: A0, b: B0, c: C0): C<C0> {
          // return C<C0>{ aa: a, bb: b, cc: c };
        }
      }

      // Returns child type using partial Member reference
      makeC<C0>(self: B<B0>, a: A0, b: B0, c: C0): C<C0> {
        // return C<C0>{ aa: a, bb: b, cc: c };
      }
    }

    // Method that returns B<B0>.C<C0> with arguments threaded through:
    build<B0, C0>(self: A<A0>, a: A0, b: B0, c: C0): B<B0>.C<C0> {
      // let out: B<B0>.C<C0> = B<B0>.C<C0>{ aa: a, bb: b, cc: c };
      // return out;
    }
  }

  // Cross-instantiation check: same decls with different concretes
  test_multi() {
    let a1 = A<i32>{};
    let a2 = A<u8>{};

    // trigger: A<i32>.B<u16>.C<u32>
    // let c1: A<i32>.B<u16>.C<u32> = a1.build<u16, u32>(1 as i32, 2 as u16, 3 as u32);

    // trigger: A<u8>.B<u8>.C<i8>
    // let c2: A<u8>.B<u8>.C<i8> = a2.build<u8, i8>(1 as u8, 2 as u8, 3 as i8);

    a1; a2;
    // c1; c2;
  }
}

// --- File: matrix/linear.hz --------------------------------------------------
namespace Lin {
  struct Mat<R, C, T> {
    struct Row<Idx> { i: Idx; }
    struct Col<Idx> { j: Idx; }

    // A method that returns a nested type depending on both parent and method generics
    getRow<Ix>(self: Mat<R, C, T>, ix: Ix): Row<Ix> {
      // return Row<Ix>{ i: ix };
    }

    getCol<Ix>(self: Mat<R, C, T>, ix: Ix): Col<Ix> {
      // return Col<Ix>{ j: ix };
    }

    // Compose nested types in the return type using partial refs
    cross<Ix, Jx>(self: Mat<R, C, T>, i: Ix, j: Jx): Row<Ix> {
      // let r: Row<Ix> = Row<Ix>{ i: i };
      // let c: Col<Jx> = Col<Jx>{ j: j };
      // r; c;
      // return r;
    }
  }

  test() {
    let m = Mat<2, 3, f64>{};
    // let r = m.getRow<u8>(1 as u8);
    // let c = m.getCol<u8>(2 as u8);
    // let rr = m.cross<u8, u8>(3 as u8, 4 as u8);

    m; // r; c; rr;
  }
}

// --- File: deep/merges.hz ----------------------------------------------------
namespace Merges {
  // Intentionally reuse generic names at multiple levels to test overwrite precedence
  struct Outer<T> {
    struct Mid<T> {
      struct Inner<T> {
        a: T; // should refer to Inner's T
        b: T; // same
      }

      build<T>(self: Mid<T>, x: T): Inner<T> {
        // let res: Inner<T> = Inner<T>{ a: x, b: x };
        // return res;
      }
    }

    make<T>(self: Outer<T>, x: T): Mid<T>.Inner<T> {
      // let m: Mid<T>.Inner<T> = Mid<T>.Inner<T>{ a: x, b: x };
      // return m;
    }
  }

  // Same names, but refer to different levels explicitly to test scoping
  struct Nest<A> {
    struct Nest<B> {
      struct Nest<C> { a: A; b: B; c: C; }
      mk<C>(self: Nest<B>, a: A, b: B, c: C): Nest<C> {
        // return Nest<C>{ a: a, b: b, c: c };
      }
    }
  }

  test() {
    let o = Outer<i32>{};
    // let _ = o.make<i32>(1 as i32);

    let n = Nest<i8>{};
    // let m: Nest<i8>.Nest<u8>.Nest<i16> = n.Nest<u8>.mk<i16>(1 as i8, 2 as u8, 3 as i16);
    o; n; // _;
  }
}

// --- File: cross/compose.hz --------------------------------------------------
namespace Compose {
  // Compose types from different namespaces via fully qualified paths

  struct Wrap<T> { x: T; }

  // Return type pulls nested types from DS::Map and Graph::Graph
  make_combo<K, V, W, ID>(
    k: K, v: V, w: W, id: ID
  ): DS.Map<K>.Bucket<ID>.Cell<Graph.Graph<W>.Layers<V>.Node<ID>> {
    // let node: Graph.Graph<W>.Layers<V>.Node<ID> = Graph.Graph<W>.Layers<V>.Node<ID>{ id: id, data: v };
    // let cell: DS.Map<K>.Bucket<ID>.Cell<Graph.Graph<W>.Layers<V>.Node<ID>>
    //   = DS.Map<K>.Bucket<ID>.Cell<Graph.Graph<W>.Layers<V>.Node<ID>>{ idx: id, payload: node };
    // return cell;
  }
}

// --- File: main.hz -----------------------------------------------------------
namespace Main {
  main(): i32 {
    // Trigger a variety of instantiations (commented constructs force elaboration on type check)
    let m = DS.Map<i32>{};
    let cell = m.make_cell<i16, u8, i8>(m, 1 as i32, 2 as i16, 9 as u8, 7 as i8);

    let g = Graph.Graph<u32>{};
    let n = g.mkLayerNode<i64, u8>(g, 5 as u8, 6 as i64);

    let a = Algebra.Monoid<i32>{};
    let op = a.use<u8, i16>(a, 1 as i16, 2 as i16);

    let tw = Tower.A<i32>{};
    let c = tw.build<u16, u8>(tw, 1 as i32, 2 as u16, 3 as u8);

    let M = Lin.Mat<2, 2, f64>{};
    let r = M.getRow<u8>(M, 1 as u8);

    let combo = Compose.make_combo<i32, i16, u8, u16>(
      1 as i32, 2 as i16, 3 as u8, 4 as u16
    );

    // DS.Shadow and Algebra.Shadow force shadowing paths
    let sh = DS.Shadow<i32>{};
    let _cs = sh.use_shadow<i32>(sh, 1 as i32, 2 as i32);

    let s2 = Algebra.Shadow<i32>{};
    let _ss = s2.build<i16>(s2, 7 as i16);

    // static_asserts (imaginary) you can enable later:
    // static_assert(Core.type_equal< typeof(cell), DS.Map<i32>.Bucket<u8>.Cell<i8> >());
    // static_assert(Core.type_equal< typeof(n), Graph.Graph<u32>.Layers<i64>.Node<u8> >());
    // static_assert(Core.type_equal< typeof(op), Algebra.Monoid<i32>.Op<i16> >());
    // static_assert(Core.type_equal< typeof(c), Tower.A<i32>.B<u16>.C<u8> >());
    // static_assert(Core.type_equal< typeof(r), Lin.Mat<2,2,f64>.Row<u8> >());
    // static_assert(Core.type_equal< typeof(combo),
    //     DS.Map<i32>.Bucket<u16>.Cell<Graph.Graph<u8>.Layers<i16>.Node<u16>> >());

    // Touch values to avoid “unused”
    cell; n; op; c; r; combo; _cs; _ss;
    m; g; a; tw; M; sh; s2;

    return 0 as i32;
  }
}

// HAZE NAME-RESOLUTION / GENERICS / NAMESPACE STRESS TEST SUITE
// -----------------------------------------------------------------------------
// This suite is designed to hammer:
//  - multi-level namespaces
//  - identical namespace names in different modules
//  - shadowing of names (types, values, namespaces)
//  - selective imports & aliasing
//  - nested generic types (Member types inside generic structs)
//  - partial member-type references inside a generic context (e.g., `B<u8>`
//    inside `A<T>` should resolve to `A<T>.B<u8>` without explicit qualification)
//  - ambiguous references (intentional errors)
//  - forward references across namespaces
//  - const generic–like parameters (if supported), or substitute with value-params
//
// Conventions used:
//  - `static_assert(type_equal<X, Y>)` stands for a compile-time check that X == Y.
//  - `expect_error` indicates a line that SHOULD produce a diagnostic.
//  - Types: `u8`, `u16`, `u32`, `u64`, `i32`, `bool`, `void` assumed to exist.
//  - Functions like `type_equal<T, U>() -> bool` are thought to be built-ins in the
//    type system for testing; if you don’t have them, swap for your checker.
//  - `using` imports a namespace (or selective symbols) into the current scope.
//  - `alias` creates a type alias.
// -----------------------------------------------------------------------------

// --- File: common/core.hz -----------------------------------------------------
namespace Core {
  // A simple equality helper in the type system; adapt to your test harness
  extern type_equal<T, U>(): boolean; // compile-time intrinsic

  // A small marker types to help identity checks
  struct MarkerA {}
  struct MarkerB {}

  // Vec appears in Core
  struct Vec<T> {
    data: T*;
    len:  u32;
  }
}

// --- File: physics/math.hz ----------------------------------------------------
namespace Math { // NOTE: a top-level namespace named Math (module: physics)
  struct Vec<T> { // Intentionally the same type name as Core.Vec
    x: T; 
    y: T;
  }

  length(v: Vec<float>): float { /* impl irrelevant */ return 0.0; }
}

// --- File: graphics/math.hz ---------------------------------------------------
namespace Math { // Another top-level namespace named Math (module: graphics)
  struct Color {
    r: u8; 
    g: u8; 
    b: u8;
  }

  blend(a: Color, b: Color): Color { 
    return a; 
  }
}

// --- File: util/aliases.hz ----------------------------------------------------
namespace Util {
  // Qualifier/alias tests
//   alias GVecF64 = ::Math.Vec<f64>;       // EXPECT: resolves to physics.Math.Vec<f64> or
//                                          // whichever `Math` is imported (see imports below).
//   alias CColor  = ::Math.Color;          // EXPECT: resolves to graphics.Math.Color when imported correctly.

  // A namespace nested inside Util to test shadowing
  namespace InnerMath {
    dot(a: Math.Vec<f64>, b: Math.Vec<f64>): f64 { 
        return 0.0 as f64; 
    }
  }
}

// --- File: model/shapes.hz ----------------------------------------------------
namespace Model {
  // A generic with a nested member-type B<U>
  struct A<T> {
    value: T;

    // Nested type depending on outer T
    struct B<U> {
      outer: T; // captures A<T>.T
      inner: U;
    };

    // Nested namespace to test same-name shadowing
    struct Math {
      struct Vec<T> { 
        x: T; 
        y: T; 
      }
    }

    // Method that uses partial inner type reference without `A<T>.` prefix
    makeB<U>(self: A<T>, u: U): B<U> { 
      // EXPECT: resolves to A<T>.B<U>
      let b: B<U> = B<U>{ outer: self.value, inner: u };
      return b;
    }

    // Method referencing sibling nested namespace type without full qualification
    makeLocalVec(self: A<T>, x: T, y: T): Math.Vec<T> { 
      // resolves to A<T>.Math.Vec<T>
      return Math.Vec<T>{ x: x, y: y };
    }
  }

  // Cross-generic reference: inside A<i32>, B<u8> must be the specialized member type
  test_partial_member_access() {
    let a: A<i32> = A<i32>{ value: 7 as i32 };
    let b: A<i32>.B<u8> = a.makeB<u8>(a, 5 as u8);

    // Partial reference inside the method ensured B<u8> bound to the same A<i32> instance
    // static_assert(Core.type_equal< typeof(b), A<i32>.B<u8> >());
  }
}

// --- File: imports/ambiguous.hz -----------------------------------------------
// This file intentionally creates ambiguity to ensure the resolver emits diagnostics
namespace ImportsAmbiguous {
  // Pull in *both* Math namespaces into the same scope via aliases
//   using PhysicsMath = ::Math; // Suppose import path resolves to physics.Math (configured by build)
//   using GraphicsMath = ::Math; // Suppose another import brings graphics.Math too (different module)

  // Re-expose both under the same short name – should be illegal/ambiguous unless disambiguated
  // expect_error: ambiguous namespace import
  // using Math = PhysicsMath;
  // using Math = GraphicsMath; // two different targets for the same alias name

  // Explicit qualification should be fine
//   use_both() {
//     let v = PhysicsMath.Vec<f64>{ x: 1.0, y: 2.0 }; // physics.Math.Vec
//     let c = GraphicsMath.Color{ r: 1, g: 2, b: 3 };  // graphics.Math.Color
//     let _ = PhysicsMath.length(v);
//     let _ = GraphicsMath.blend(c, c);
//   }
}

// --- File: imports/selective.hz ----------------------------------------------
namespace ImportsSelective {
  // Import only a symbol from physics Math
//   using ::Math.Vec;    // expects to pull the Vec in-scope (physics one)
//   // Import only Color from graphics Math
//   using ::Math.Color;  // expects to pull Color in-scope (graphics one)

//   fn test() {
//     let v = Vec<f64>{ x: 0.0, y: 0.0 }; // should bind to physics.Math.Vec
//     let c = Color{ r: 0, g: 0, b: 0 };  // should bind to graphics.Math.Color
//   }
}

// --- File: shadowing/local_vs_namespace.hz -----------------------------------
namespace Shadowing {
  namespace Math { 
    struct S { k: u8; }
    struct Vec<T> { 
        x: T; 
        y: T; 
    } 
  }

  f() {
    let Math = 42; // value shadows the namespace name `Math` in this local scope
    // expect_error: `Math.Vec` here should refer to the *value* `Math`, not a namespace
    // let v = Math.Vec<f64>{ x: 1.0, y: 2.0 };

    let v2 = Shadowing.Math.Vec<float>{ x: 1.0, y: 2.0 };

    // Inner namespace still accessible fully qualified
    let s = Shadowing.Math.S{ k: 5 as u8 };
    Math; 
    v2; 
    s;
  }
}

// --- File: forward/refs.hz ----------------------------------------------------
namespace ForwardRefs {
  // Use before definition via namespace qualification
  area(circle: Shape.Circle): f64 { 
    return Shape.area(circle); 
  }

  namespace Shape {
    struct Circle { r: f64; }
    area(c: Circle): f64 { 
        return 3.14159 as f64 * c.r * c.r; 
    }
  }
}

// --- File: nested/generics_cross.hz ------------------------------------------
namespace Nested {
  struct Outer<X> {
    struct Mid<Y> {
      struct Inner<ZZ> {
        a: X; b: Y; c: ZZ;
      };
    };

    // Inside Outer<X>, allow `Mid<Y>.Inner<Z>` with partial reference, and also just `Inner<Z>`
    build<Y, Z>(self: Outer<X>, x: X, y: Y, z: Z): Mid<Y>.Inner<Z> {
      let m: Mid<Y>.Inner<Z> = Mid<Y>.Inner<Z>{ a: x, b: y, c: z };
      // Short form inside the same generic nest:
      let s: Inner<Z> = m; // EXPECT: resolves to Mid<Y>.Inner<Z> bound by the current Y
    //   static_assert(Core.type_equal< typeof(s), Mid<Y>.Inner<Z> >());
      return m;
    }
  }

  test() {
    let o = Outer<i32>{};
    let r = o.build<u16, u8>(o, 1 as i8, 2 as u8, 3 as u8);
    // static_assert(Core.type_equal< typeof(r), Outer<i32>.Mid<u16>.Inner<u8> >());
  }
}

// --- File: same_name/type_value_ns.hz ----------------------------------------
namespace TVN {
  // Same identifier used as namespace, type, and variable in different scopes
  struct Box { n: i32; struct T { n: i32; } } // type named Box in the same namespace TVN

  g() {
    let Box = 3; // value named Box shadows the type `Box` *in this block only*
    // expect_error: Box{ n: 1 } — attempts to construct the value-`Box` as a type
    // let x = Box{ n: 1 };

    // Disambiguate with `::TVN.Box` (the *type*)
    let y = TVN.Box{ n: 1 };

    // Use the *namespace* TVN.Box to access nested type `T`
    let z = TVN.Box.T{ n: 2 };
    Box; 
    y; 
    z;
  }
}

// --- File: prefer_local_member_type.hz ---------------------------------------
namespace Preference {
  struct A<T> {
    struct B<U> { outer: T; inner: U; };
  }
  struct B<T> { k: T; } // a *top-level* B that should NOT be chosen when inside A<T>

  test() {
    let a = A<i32>{};
    // Here, bare `B<u8>` inside the expression that has `A<i32>` context should resolve to `A<i32>.B<u8>`
    let x: A<i32>.B<u8> = a.B<u8>{ outer: 1, inner: 2 }; // explicit qualified construction

    // If your language supports it, allow elided `A<i32>.` when the lookup receiver is clear:
    let y: A<i32>.B<u8> = B<u8>{ outer: 1, inner: 2 }; // EXPECT: binds to A<i32>.B<u8>, not ::Preference.B<u8>

    // static_assert(Core.type_equal< typeof(y), A<i32>.B<u8> >());
  }
}

// --- File: imports/mixed_paths.hz --------------------------------------------
namespace MixedPaths {
  // Bring in symbols to create potential collisions intentionally
//   using ::Core.Vec;           // Core.Vec<T>
//   using ::Math.Vec as PVec;   // physics.Math.Vec<T> aliased as PVec
//   using ::Math.Color;         // graphics.Math.Color

  h() {
    let a: Vec<i32> = Vec<i32>{ data: null, len: 0 }; // Core.Vec
    let b: PVec<f64> = PVec<f64>{ x: 0.0, y: 0.0 };   // physics.Math.Vec
    let c: Color = Color{ r: 0, g: 0, b: 0 };         // graphics.Math.Color
    a; 
    b; 
    c;
  }
}

// --- File: negative/ambiguous_member_in_generic.hz ---------------------------
namespace Negative {
  struct A<T> {
    struct B<U> { t: T; u: U; };
  }
  struct B<T> { t: T; }

  bad(a: A<i32>) {
    // expect_error: ambiguous `B<u8>` — could refer to A<i32>.B<u8> or ::Negative.B<u8> without contextual bias
    // let foo: B<u8> = B<u8>{ t: 1, u: 2 };

    // Disambiguate explicitly:
    let ok1: A<i32>.B<u8> = A<i32>.B<u8>{ t: 1, u: 2 };
    let ok2: Negative.B<u8> = Negative.B<u8>{ t: 1 };
    a; 
    ok1; 
    ok2;
  }
}

// --- File: main.hz ------------------------------------------------------------
namespace Main {
//   using ::Core;
//   using ::Model;
//   using ::Nested;
//   using ::ImportsSelective;
//   using ::MixedPaths;

  main(): i32 {
    // Model.test_partial_member_access();
    // Nested.test();
    // ImportsSelective.test();
    // MixedPaths.h();
    return 0;
  }
}

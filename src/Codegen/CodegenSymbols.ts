import { getType, type Semantic, type SemanticResult } from "../Semantic/SemanticSymbols";
import { InternalError } from "../shared/Errors";

export namespace Codegen {
  export function mangleDatatype(sr: SemanticResult, type: Semantic.Datatype) {
    switch (type.variant) {
      // =================================================================================================================
      // =================================================================================================================
      // =================================================================================================================

      case "Struct": {
        let nesting = "";
        if (this.parentSymbol) {
          let p: Datatype.BaseDatatype | undefined = module.parsedStore
            .getSymbolOrFail(this.parentSymbol)
            .asDatatypeSymbol().type;
          while (p) {
            if (!p.isStruct() || !p.isNamespace()) {
              throw new ImpossibleSituation();
            }
            nesting = p.mangle(module) + nesting;
            p = p.parentSymbol
              ? module.parsedStore.getSymbolOrFail(this.parentSymbol).asDatatypeSymbol().type
              : undefined;
          }
        }
        if (this.linkage === ELinkage.Internal) {
          let innerMangling = this.name.length.toString() + this.name;
          if (this.generics.length > 0) {
            innerMangling += "I";
            for (const { name, type } of this.generics) {
              if (type) {
                const typeSym = module.parsedStore.getSymbolOrFail(type);
                if (typeSym.isDatatype()) {
                  innerMangling += typeSym.type.mangle(module);
                } else if (typeSym.isConstant()) {
                  innerMangling += typeSym.constant.value.toString().replaceAll(".", "_");
                } else {
                  throw new InternalError(
                    "A symbol that is not a constant or a datatype went into a generic",
                  );
                }
              } else {
                innerMangling += name + "_";
              }
            }
            innerMangling += "E";
          }

          if (nesting !== "") {
            return `N${nesting}${innerMangling}E`;
          } else {
            return innerMangling;
          }
        } else {
          return this.name;
        }
      }

      // =================================================================================================================
      // =================================================================================================================
      // =================================================================================================================

      case "Function": {
        break;
      }

      // =================================================================================================================
      // =================================================================================================================
      // =================================================================================================================

      case "Namespace": {
        break;
      }

      // =================================================================================================================
      // =================================================================================================================
      // =================================================================================================================

      case "Primitive": {
        break;
      }

      // =================================================================================================================
      // =================================================================================================================
      // =================================================================================================================

      case "Deferred": {
        throw new InternalError("Cannot mangle deferred datatype");
      }
    }
  }

  export function mangleSymbol(sr: SemanticResult, symbol: Semantic.Symbol) {
    switch (symbol.variant) {
      // =================================================================================================================
      // =================================================================================================================
      // =================================================================================================================

      case "Datatype": {
        const type = getType(sr, symbol.type);
        // if (Conversion.isStruct(type) && type.externLanguage !== EExternLanguage.None) {
        //   return type.mangle(module);
        // } else {
        return mangleDatatype(sr, type);
        // }
      }

      // =================================================================================================================
      // =================================================================================================================
      // =================================================================================================================

      case "FunctionDeclaration": {
        break;
      }

      // =================================================================================================================
      // =================================================================================================================
      // =================================================================================================================

      case "FunctionDefinition": {
        break;
      }

      // =================================================================================================================
      // =================================================================================================================
      // =================================================================================================================

      case "GenericParameter": {
        break;
      }

      // =================================================================================================================
      // =================================================================================================================
      // =================================================================================================================

      case "Variable": {
        break;
      }
    }
  }
}

declare "C" printf(str: stringview, ...);
declare "C" calloc(num: u64, size: u64): RawPtr<none>;
declare "C" free(ptr: RawPtr<none>);
declare "C" abort();
declare "C" realloc(ptr: RawPtr<none>, newSize: u64): RawPtr<none>;
declare "C" sqrt(v: f64): f64;
declare "C" sqrtf(v: f32): f32;
declare "C" pow(a: f64, b: f64): f64;
declare "C" powf(a: f32, b: f32): f32;
declare "C" sin(v: f64): f64;
declare "C" sinh(v: f64): f64;
declare "C" cos(v: f64): f64;
declare "C" cosh(v: f64): f64;
declare "C" tan(v: f64): f64;
declare "C" atan2(y: f64, x: f64): f64;

inject "#include <GLFW/glfw3.h>";
declare "C" struct GLFWwindow {};
declare "C" struct GLFWmonitor {};
declare "C" glfwInit(): boolean;
declare "C" glfwTerminate(): none;
declare "C" glfwMakeContextCurrent(w: RawPtr<GLFWwindow>);
declare "C" glfwWindowShouldClose(w: RawPtr<GLFWwindow>): boolean;
declare "C" glfwCreateWindow(width: i32, height: i32, title: stringview, monitor: RawPtr<GLFWmonitor>, share: RawPtr<GLFWwindow>): RawPtr<GLFWwindow>;
declare "C" glClear(flag: i64): boolean;
declare "C" glfwSwapBuffers(w: RawPtr<GLFWwindow>);
declare "C" glfwPollEvents();
declare "C" glfwSwapInterval(flag: i8);
declare "C" glfwGetTime(): f64;
declare "C" glfwGetKey(w: RawPtr<GLFWwindow>, key: i32): i32;
declare "C" glfwGetMouseButton(w: RawPtr<GLFWwindow>, button: i32): i32;

struct LogContext {
  trace: (fmt: stringview, ...) => none;
  info: (fmt: stringview, ...) => none;
  debug: (fmt: stringview, ...) => none;
  warn: (fmt: stringview, ...) => none;
  error: (fmt: stringview, ...) => none;
}

struct MemContext {
  alloc: (size: u64) => RawPtr<none>;
}

struct Context {
  log: LogContext;
  mem: MemContext;
};

struct Result<TSuccess, TError> {
  unsafe_union {
    success: TSuccess;
    error: TError;
  }
  isSuccess: boolean;
}

struct Vec2 {
  x: f64;
  y: f64;

  constructor(x: f64, y: f64): Vec2 {
    return Vec2 {
      .x: x,
      .y: y,
    };
  }

  neg(): Vec2 {
    return Vec2(-this.x, -this.y);
  }

  add(other: Vec2): Vec2 {
    return Vec2(this.x + other.x, this.y + other.y);
  }

  sub(other: Vec2): Vec2 {
    return Vec2(this.x - other.x, this.y - other.y);
  }

  mul(v: f64): Vec2 {
    return Vec2(this.x * v, this.y * v);
  }

  div(v: f64): Vec2 {
    return Vec2(this.x / v, this.y / v);
  }

  length(): f64 {
    return sqrt(pow(this.x, 2) + pow(this.y, 2));
  }

  normalize(): Vec2 {
    return this.div(this.length());
  }

  dot(other: Vec2): f64 {
    return this.x * other.x + this.y * other.y;
  }
}

struct Color {
  r: u8;
  g: u8;
  b: u8;

  constructor(r: u8, g: u8, b: u8): Color {
    return Color {
      .r: r,
      .g: g,
      .b: b,
    };
  }
}

declare "C" initClayAndRSGL(window: RawPtr<GLFWwindow>);
declare "C" beginFrame();
declare "C" frame();
declare "C" endFrame();
declare "C" destroyClayAndRSGL(window: RawPtr<GLFWwindow>);

declare "C" text(text: stringview, fontSize: i32);
// declare "C" _div(cb: () => none);

div(cb: () => none) {
  __c__("Clay_ElementDeclaration elem = { .layout = { .sizing = { CLAY_SIZING_FIXED(400), CLAY_SIZING_FIXED(200) } }, .backgroundColor = { 217, 91, 67, 255 } };");
  __c__("CLAY(elem) {");
    // if (cb) {
      cb();
    // }
  __c__("}");
}

struct Window {
    glfwWindow: RawPtr<GLFWwindow>;

    constructor(width: i32, height: i32, title: stringview): Result<Window, stringview> {
      __c__("glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);");
      __c__("glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);");
      __c__("glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);");
      const window = glfwCreateWindow(width, height, title, 0 as RawPtr<GLFWmonitor>, 0 as RawPtr<GLFWwindow>);
      if not window {
          return Result<Window, stringview> {
            .error: "Window creation failed",
            .isSuccess: false,
          };
      }

      glfwMakeContextCurrent(window);
      glfwSwapInterval(1);

      initClayAndRSGL(window);

      return Result<Window, stringview> {
        .success: Window {
          .glfwWindow: window,
        },
        .isSuccess: true,
      };
    }

    makeContextCurrent() {
      glfwMakeContextCurrent(this.glfwWindow);
    }

    setVSync(enabled: boolean) {
      glfwSwapInterval(enabled);
    }

    shouldClose(): boolean {
      return glfwWindowShouldClose(this.glfwWindow);
    }

    swapBuffers() {
      glfwSwapBuffers(this.glfwWindow);
    }

    pollEvents() {
      glfwPollEvents();
    }

    getCursorPos(): Vec2 {
      const pos = Vec2(0, 0);
      __c__("glfwGetCursorPos(this->glfwWindow, &pos.x, &pos.y)");
      return pos;
    }

    getKey(key: i32): boolean {
      return glfwGetKey(this.glfwWindow, key) != 0;
    }

    getMouseButton(button: i32): boolean {
      return glfwGetMouseButton(this.glfwWindow, button) != 0;
    }
}

// declare "C" "#include <SDL2/SDL.h>";
// declare "C" "#include \"../clay.h\"";
// declare "C" "#include \"../test.c\"";
// declare "C" struct SDL_Window {};
// declare "C" struct SDL_Renderer {};
// declare "C" SDL_Init(flags: u32): i32;
// declare "C" SDL_CreateWindow(title: stringview, x: i32, y: i32, w: i32, h: i32, flags: u32): RawPtr<SDL_Window>;
// declare "C" SDL_Quit();
// declare "C" SDL_CreateRenderer(window: RawPtr<SDL_Window>, index: i32, flags: u32): RawPtr<SDL_Renderer>;
// declare "C" SDL_DestroyWindow(window: RawPtr<SDL_Window>);
// declare "C" SDL_RenderPresent(window: RawPtr<SDL_Window>);

//declare "C" drawLine();

// declare "C" struct SDL_MouseMotionEvent {
//     type: u32;       
//     timestamp: u32;   
//     windowID: u32;
//     which: u32;       
//     state: u32;
//     x: i32;
//     y: i32;          
//     xrel: i32;
//     yrel: i32;
// }

// declare "C" struct SDL_Event {
//     type: u32;
//     motion: SDL_MouseMotionEvent;
// }

// declare "C" SDL_PollEvent(event: RawPtr<SDL_Event>): i32;
// declare "C" SDL_DestroyRenderer(renderer: RawPtr<SDL_Renderer>);

c_realloc(ptr: RawPtr<none>, newSize: u64): RawPtr<none> {
  return realloc(ptr, newSize);
}

malloc(size: u64): RawPtr<none> {
  return calloc(1, size);
}

panic(msg: stringview) {
  printf("PANIC: %s\n", msg);
  abort();
}

inject "typedef struct timespec timespec_t;";
declare "C" struct timespec_t {
  tv_sec: u64;
  tv_nsec: u64;
}

declare "C" assert(cond: boolean);

assertTypes() {
  __c__("timespec_t t");
  __c__("assert(sizeof(t.tv_sec) == 8)");
  __c__("assert(sizeof(t.tv_nsec) == 8)");
}

struct Duration {
  nanoseconds: u64;

  constructor(nanoseconds: u64): Duration {
    return Duration {
      .nanoseconds: nanoseconds,
    };
  }
}

sleep(duration: Duration) {
  const sec = duration.nanoseconds / 1000000000;
  const nsec = duration.nanoseconds - sec * 1000000000;
  __c__("struct timespec t;");
  __c__("t.tv_sec = sec");
  __c__("t.tv_nsec = nsec");
  __c__("nanosleep(&t, NULL)");
}

struct MemoryBuffer {
  data: RawPtr<none>;
  size: u64;

  constructor(size: u64): MemoryBuffer {
    const a = ctx;
    const buffer = malloc(size);
    if !buffer {
      panic("Allocation failed");
    }
    return MemoryBuffer {
      .data: buffer,
      .size: size,
    };
  }

  realloc(newSize: u64) {
    ctx.log.warn("Realloc with %d, %d", this.data, newSize);
    this.data = c_realloc(this.data, newSize);
    if !this.data {
      panic("Allocation failed");
    }
    this.size = newSize;
  }
}

struct List<T> {
  buffer: MemoryBuffer;
  length: u64;

  constructor(): List<T> {
    const initialCapacity = 4;
    return List<T> {
      .buffer: MemoryBuffer(initialCapacity * sizeof<T>),
      .length: 0,
    };
  }

  reserve(size: u64): none {
    if size <= this.capacity() {
      return;
    }
    this.buffer.realloc(size * sizeof<T>);
  }

  push(n: T) {
    if this.length >= this.capacity() {
      this.reserve(this.length * 2);
    }
    const buf = this.buffer.data as RawPtr<T>;
    __c__("buf[this->length] = n");
    this.length = this.length + 1;
  }

  pop(): T {
    const back = this.get(this.length - 1);
    this.length = this.length - 1;
    return back;
  }

  get(n: u64, dummyValue: T): T {
    if n < 0 or n >= this.length {
      panic("OUT OF BOUNDS");
    }
    const buf = this.buffer.data as RawPtr<T>;
    const result: T = dummyValue;
    __c__("result = buf[n]");
    return result;
  }

  capacity(): u64 {
    return this.buffer.size / sizeof<T>;
  }

  clear() {
    this.length = 0;
  }
}

fib() {
  const fibs = List<i32>();
  fibs.push(0);
  fibs.push(1);
  const count = 10;

  // const i = 2;
  // while (i < count) {
  //   fibs.push(fibs.get(i - 1) + fibs.get(i - 2));
  //   printf("Found fib number: %d\n", fibs.get(fibs.length - 1));
  //   i++;
  // }
}

// declare "C" draw();
// declare "C" init();
// declare "C" exitt();
// inject "#define TRAY_APPINDICATOR 1";
// inject "#include \"../tray.h\"";
inject "#include \"../gl.c\"";
prebuildcmd "pkg-config --version";
// link "$(pkg-config --cflags --libs gtk+-3.0)"
// link "$(pkg-config --cflags --libs appindicator3-0.1)"
link "-lGL -Iclay -lm -lglfw"

drawLine(p1: Vec2, p2: Vec2, thickness: f64, color: Color) {
  if thickness > 7 {
    thickness = 7;
  }
  __c__("RSGL_drawLine((RSGL_point) { p1.x, p1.y }, (RSGL_point) { p2.x, p2.y }, thickness, RSGL_RGB(color.r, color.g, color.b))");
  __c__("RSGL_drawCircle((RSGL_circle) { p1.x - thickness / 2.0, p1.y - thickness / 2.0, thickness }, RSGL_RGB(color.r, color.g, color.b))");
  __c__("RSGL_drawCircle((RSGL_circle) { p2.x - thickness / 2.0, p2.y - thickness / 2.0, thickness }, RSGL_RGB(color.r, color.g, color.b))");
}

drawCircle(center: Vec2, radius: i16, color: Color) {
  __c__("RSGL_drawCircle((RSGL_circle) { center.x - radius, center.y - radius, radius * 2 }, RSGL_RGB(color.r, color.g, color.b))");
}

drawTriangle(p1: Vec2, p2: Vec2, p3: Vec2, color: Color) {
  __c__("RSGL_drawTriangle((RSGL_triangle) { .p1 = (RSGL_point) { p1.x, p1.y }, .p2 = (RSGL_point) { p2.x, p2.y }, .p3 = (RSGL_point) { p3.x, p3.y } }, RSGL_RGB(color.r, color.g, color.b))");
}

getTime(): f64 {
  return glfwGetTime();
}

PI(): f64 {
  const pi: f64 = 0;
  __c__("pi = M_PI");
  return pi;
}

radToDeg(v: f64): f64 {
  return v / PI() * 180;
}

degToRad(v: f64): f64 {
  return v * PI() / 180;
}

drawVector(vector: Vec2, position: Vec2, color: Color) {
  const arrowLength = 25.0;
  const arrowAngle = degToRad(30);
  const lineThickness = 2;

  if vector.length() < arrowLength * 4 {
    arrowLength = vector.length() / 4.0;
  }

  const tip = position.add(vector);
  const dir = vector.normalize();
  const sidedir = Vec2(dir.y, -dir.x);
  drawLine(position, tip, lineThickness, color);
  const cross = tip.sub(dir.mul(arrowLength));
  const sideVec = sidedir.mul(arrowLength * tan(arrowAngle / 2));
  drawTriangle(tip, cross.add(sideVec), cross.sub(sideVec), color);
}

window(): i32 { 
  if not glfwInit() {
    ctx.log.error("Initializing GLFW failed");
    return 0;
  }

  // init();
  const windowResult = Window(1080, 720, "Test 1");
  if not windowResult.isSuccess {
      printf("%s\n", windowResult.error);
      glfwTerminate();
      return 0;
  }
  const window = windowResult.success;

  const v_phi_const = 50;
  const R = 300;

  const P = Vec2(0, 0);
  const velocity = Vec2(0, 0);
  const acceleration = Vec2(0, 0);

  const oldTime = getTime();
  const startTime = getTime();

  const path = List<Vec2>();

  while !window.shouldClose() {
    beginFrame();
    frame();

    // text("Hallo cooler Test!", 60);
    // div(() => {
    //   text("Oh Yeah!", 18);
    // });

    window.pollEvents();
    const now = getTime();
    const dt = now - oldTime;
    oldTime = now;
    const elapsed = now - startTime;

    const mouse = window.getCursorPos();

    if window.getKey(32) {
      P = Vec2(R, 0);
      velocity = Vec2(0, v_phi_const);
      acceleration = Vec2(0, 0);
      startTime = getTime();
      path.clear();
    }

    const origin = Vec2(200, 600);
    const m = mouse.sub(origin);
    m = Vec2(m.x, -m.y);
    if window.getMouseButton(0) {
      P = Vec2(m.x, m.y);
      velocity = Vec2(0, v_phi_const);
      acceleration = Vec2(0, 0);
      startTime = getTime();
      // path = List<Vec2>();
      path.clear();
    }

    // =========================================

    const phi = atan2(P.y, P.x);

    const e_r = P.normalize();
    const e_phi = Vec2(-e_r.y, e_r.x);

    const v_phi = velocity.dot(e_phi);
    const v_r = velocity.dot(e_r);

    const a_phi = pow(v_phi, 2) / R * phi;
    const a_r = pow(v_phi, 2) / R * 
                (
                    cosh((2*v_phi*elapsed) / (sqrt(2) * R)) 
                    - 
                    1/pow(cosh((v_phi*elapsed)/(sqrt(2)*R)), 2));

    acceleration = Vec2(a_r * cos(phi) - a_phi * sin(phi), a_r * sin(phi) + a_phi * cos(phi));
    ctx.log.debug("v_phi: %f", v_phi);

    velocity = velocity.add(acceleration.mul(dt));
    P = P.add(velocity.mul(dt));

    path.push(P);

    const a = 0;
    while a < path.length - 1 {
      const dummy = Vec2(0, 0);
      drawLine(origin.add(Vec2(path.get(a, dummy).x, -path.get(a, dummy).y)), origin.add(Vec2(path.get(a + 1, dummy).x, -path.get(a + 1, dummy).y)), 1, Color(255, 255, 255));
      a++;
    }

    drawVector(Vec2(600, 0), origin, Color(255, 255, 255));
    drawVector(Vec2(0, -500), origin, Color(255, 255, 255));

    // e_r und e_phi
    drawVector(Vec2(e_phi.x * 100, -e_phi.y * 100), origin.add(Vec2(P.x, -P.y)), Color(255, 255, 255));
    drawVector(Vec2(e_r.x * 100, -e_r.y * 100), origin.add(Vec2(P.x, -P.y)), Color(255, 255, 255));

    // v
    drawVector(Vec2(velocity.x, -velocity.y), origin.add(Vec2(P.x, -P.y)), Color(255, 0, 0));
    drawVector(Vec2(e_phi.x * v_phi, -e_phi.y * v_phi), origin.add(Vec2(P.x, -P.y)), Color(255, 0, 0));
    drawVector(Vec2(e_r.x * v_r, -e_r.y * v_r), origin.add(Vec2(P.x, -P.y)), Color(255, 0, 0));

    // a
    const scaleA = 5;
    drawVector(Vec2(acceleration.x * scaleA, -acceleration.y * scaleA), origin.add(Vec2(P.x, -P.y)), Color(0, 255, 0));
    drawVector(Vec2(e_phi.x * a_phi * scaleA, -e_phi.y * a_phi * scaleA), origin.add(Vec2(P.x, -P.y)), Color(0, 255, 0));
    drawVector(Vec2(e_r.x * a_r * scaleA, -e_r.y * a_r * scaleA), origin.add(Vec2(P.x, -P.y)), Color(0, 255, 0));

    drawCircle(origin.add(Vec2(P.x, -P.y)), 5, Color(0, 255, 0));

    endFrame();
    window.swapBuffers();
  }

  destroyClayAndRSGL(window.glfwWindow);

  // exitt();
  glfwTerminate();
  return 0;
}

main(): i32 {
  assertTypes();
  ctx.log.trace = (fmt: stringview, ...) => {
    printf("[\033[37mtrace\033[0m] ");
    __c__("va_list args");
    __c__("va_start(args, fmt)");
    __c__("vprintf(fmt, args)");
    __c__("va_end(args)");
    printf("\n");
  };
  ctx.log.info = (fmt: stringview, ...) => {
    printf("[\033[32minfo\033[0m] ");
    __c__("va_list args");
    __c__("va_start(args, fmt)");
    __c__("vprintf(fmt, args)");
    __c__("va_end(args)");
    printf("\n");
  };
  ctx.log.debug = (fmt: stringview, ...) => {
    printf("[\033[34mdebug\033[0m] ");
    __c__("va_list args");
    __c__("va_start(args, fmt)");
    __c__("vprintf(fmt, args)");
    __c__("va_end(args)");
    printf("\n");
  };
  ctx.log.warn = (fmt: stringview, ...) => {
    printf("[\033[33mwarn\033[0m] ");
    __c__("va_list args");
    __c__("va_start(args, fmt)");
    __c__("vprintf(fmt, args)");
    __c__("va_end(args)");
    printf("\n");
  };
  ctx.log.error = (fmt: stringview, ...) => {
    printf("[\033[31merror\033[0m] ");
    __c__("va_list args");
    __c__("va_start(args, fmt)");
    __c__("vprintf(fmt, args)");
    __c__("va_end(args)");
    printf("\n");
  };
  ctx.mem.alloc = (size: u64): RawPtr<none> => {
    return malloc(size);
  };

  // fib(10);
  // init(); 
  // test2(); 
  // return 0;
  return window();
}
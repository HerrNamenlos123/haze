declare "C" printf(str: stringview, ...);
declare "C" calloc(num: u64, size: u64): RawPtr<none>;
declare "C" free(ptr: RawPtr<none>);
declare "C" abort();
declare "C" realloc(ptr: RawPtr<none>, newSize: u64): RawPtr<none>;

declare "C" "#include <GLFW/glfw3.h>";
declare "C" struct GLFWwindow {};
declare "C" glfwInit(): boolean;
declare "C" glfwTerminate(): none;
declare "C" glfwCreateWindow(): RawPtr<GLFWwindow>;
declare "C" glfwMakeContextCurrent(w: RawPtr<GLFWwindow>);
declare "C" glfwWindowShouldClose(w: RawPtr<GLFWwindow>): boolean;
declare "C" glClear(flag: i64): boolean;
declare "C" glfwSwapBuffers(w: RawPtr<GLFWwindow>);
declare "C" glfwPollEvents();
declare "C" glfwSwapInterval(flag: i8);

struct Result<TSuccess, TError> {
  unsafe_union {
    success: TSuccess;
    error: TError;
  }
  isSuccess: boolean;
}

struct Window {
    glfwWindow: RawPtr<GLFWwindow>;

    constructor(title: i8): Result<Window, stringview> {
      const window = glfwCreateWindow(640, 480, title, 0, 0);
      if not window {
          glfwTerminate();
          return Result<Window, stringview> {
            .error: "Window creation failed",
            .isSuccess: false,
          };
      }
      return Result<Window, stringview> {
        .success: Window {
          .glfwWindow: window,
        },
        .isSuccess: true,
      };
    }

    destructor(): none {}
}

declare "C" "#include <SDL2/SDL.h>";
declare "C" "#include \"../clay.h\"";
declare "C" "#include \"../test.c\"";
declare "C" struct SDL_Window {};
declare "C" struct SDL_Renderer {};
declare "C" SDL_Init(flags: u32): i32;
declare "C" SDL_CreateWindow(title: stringview, x: i32, y: i32, w: i32, h: i32, flags: u32): RawPtr<SDL_Window>;
declare "C" SDL_Quit();
declare "C" SDL_CreateRenderer(window: RawPtr<SDL_Window>, index: i32, flags: u32): RawPtr<SDL_Renderer>;
declare "C" SDL_DestroyWindow(window: RawPtr<SDL_Window>);
declare "C" SDL_RenderPresent(window: RawPtr<SDL_Window>);

//declare "C" drawLine();

// declare "C" struct SDL_MouseMotionEvent {
//     type: u32;       
//     timestamp: u32;   
//     windowID: u32;
//     which: u32;       
//     state: u32;
//     x: i32;
//     y: i32;          
//     xrel: i32;
//     yrel: i32;
// }

// declare "C" struct SDL_Event {
//     type: u32;
//     motion: SDL_MouseMotionEvent;
// }

// declare "C" SDL_PollEvent(event: RawPtr<SDL_Event>): i32;
// declare "C" SDL_DestroyRenderer(renderer: RawPtr<SDL_Renderer>);

c_realloc(ptr: RawPtr<none>, newSize: u64): RawPtr<none> {
  return realloc(ptr, newSize);
}

malloc(size: u64): RawPtr<none> {
  return calloc(1, size);
}

panic(msg: stringview) {
  printf("PANIC: %s\n", msg);
  abort();
}

assert(v: boolean) {
  if not v {
    panic("Assertion failed");
  }
}

assertTypes() {
  __c__("struct timespec t;");
  __c__("_H6assert(context, sizeof(t.tv_sec) == 8)");
  __c__("_H6assert(context, sizeof(t.tv_nsec) == 8)");
}

struct Duration {
  nanoseconds: u64;

  constructor(nanoseconds: u64): Duration {
    return Duration {
      .nanoseconds: nanoseconds,
    };
  }

  destructor(): none {}
}

sleep(duration: Duration) {
  const sec = duration.nanoseconds / 1000000000;
  const nsec = duration.nanoseconds - sec * 1000000000;
  __c__("struct timespec t;");
  __c__("t.tv_sec = sec");
  __c__("t.tv_nsec = nsec");
  __c__("nanosleep(&t, NULL)");
}

struct MemoryBuffer {
  data: RawPtr<none>;
  size: u64;

  constructor(size: u64): MemoryBuffer {
    const buffer = malloc(size);
    if !buffer {
      panic("Allocation failed");
    }
    return MemoryBuffer {
      .data: buffer,
      .size: size,
    };
  }

  realloc(newSize: u64) {
    this.data = c_realloc(this.data, newSize);
    if !this.data {
      panic("Allocation failed");
    }
    this.size = newSize;
  }

  destructor(): none {
    free(this.data);
  }
}

struct List<T> {
  buffer: MemoryBuffer;
  length: u64;

  constructor(): List<T> {
    const initialCapacity = 4;
    return List<T> {
      .buffer: MemoryBuffer(initialCapacity * sizeof<T>),
      .length: 0,
    };
  }

  destructor(): none {}

  reserve(size: u64): none {
    if size <= this.capacity() {
      return;
    }
    this.buffer.realloc(size * sizeof<T>);
  }

  push(n: T) {
    if this.length >= this.capacity() {
      this.reserve(this.length * 2);
    }
    const buf = this.buffer.data as RawPtr<T>;
    __c__("buf[this->length] = n");
    this.length = this.length + 1;
  }

  pop(): T {
    const back = this.get(this.length - 1);
    this.length = this.length - 1;
    return back;
  }

  get(n: T): T {
    if n < 0 or n >= this.length {
      panic("OUT OF BOUNDS");
    }
    const buf = this.buffer.data as RawPtr<T>;
    const result: T = 0;
    __c__("result = buf[n]");
    return result;
  }

  capacity(): u64 {
    return this.buffer.size / sizeof<T>;
  }
}

fib(count: i32) {
  const fibs = List<i32>();
  fibs.push(0);
  fibs.push(1);

  const i = 2;
  while (i < count) {
    fibs.push(fibs.get(i - 1) + fibs.get(i - 2));
    printf("Found fib number: %d\n", fibs.get(fibs.length - 1));
    i++;
  }
}

declare "C" draw();

window(): i32 {
  if not glfwInit() {
    printf("Failed");
    return 0;
  }

    // const window = glfwCreateWindow(640, 480, "Hello World", 0, 0);
    const window = Window("Test 1");
    if not window.isSuccess {
        glfwTerminate();
        return 0;
    }

    // glfwMakeContextCurrent(window.success.glfwWindow);
    // glfwSwapInterval(1);

    // while (!glfwWindowShouldClose(window.success.glfwWindow))
    // {
    //     draw();
    //     glfwSwapBuffers(window.success.glfwWindow);
    //     glfwPollEvents();
    // }

    glfwTerminate();
    return 0;
  // const _SDL_INIT_VIDEO = 32;

  // if (SDL_Init(_SDL_INIT_VIDEO) != 0) {
  //     // SDL_Log("SDL_Init Error: %s", SDL_GetError());
  //       printf("failed 1\n");
  //       return 1;
  //   }

  //   // Create an SDL2 window
  //   const _SDL_WINDOWPOS_CENTERED = 805240832;
  //   const _SDL_WINDOW_SHOWN = 4;
  //   const window = SDL_CreateWindow("Clay + SDL2", 
  //                                         _SDL_WINDOWPOS_CENTERED, 
  //                                         _SDL_WINDOWPOS_CENTERED, 
  //                                         800, 600, 
  //                                         _SDL_WINDOW_SHOWN);
  //   if (!window) {
  //       // SDL_Log("SDL_CreateWindow Error: %s", SDL_GetError());
  //       printf("failed 2\n");
  //       SDL_Quit();
  //       return 1;
  //   }

  //   // Create an SDL2 renderer
  //   const _SDL_RENDERER_ACCELERATED = 2;
  //   const renderer = SDL_CreateRenderer(window, -1, _SDL_RENDERER_ACCELERATED);
  //   if (!renderer) {
  //       // SDL_Log("SDL_CreateRenderer Error: %s", SDL_GetError());
  //       SDL_DestroyWindow(window);
  //       SDL_Quit();
  //       return 1;
  //   }

  //   // Initialize Clay with SDL2 renderer
  //   // clay_init(SDL_GetTicks, SDL_GetRendererTarget(renderer), renderer);

  //   // Main loop
  //   const running = true;
  //   while (running) {
  //       // printf("failed 2\n");
  //       // Handle events
  //       const _event = SDL_Event {
  //         .type: 0,
  //         .motion: SDL_MouseMotionEvent { 
  //           .type: 0,       
  //           .timestamp: 0,   
  //           .windowID: 0,
  //           .which: 0,       
  //           .state: 0,
  //           .x: 0,
  //           .y: 0,
  //           .xrel: 0,
  //           .yrel: 0,
  //         }
  //       };
  //       const event: RawPtr<SDL_Event> = 0;
  //       __c__("event = &_event");
  //       const _SDL_QUIT = 256;
  //       while (SDL_PollEvent(event)) {
  //           if (event.type == _SDL_QUIT) {
  //               running = false;
  //           }
  //       }

  //       // // Clear screen
  //       // SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
  //       // SDL_RenderClear(renderer);

  //       // // Your Clay UI rendering here
  //       // clay_render();

  //       // // Present the renderer
  //       SDL_RenderPresent(renderer);
  //   }

  //   // Cleanup
  //   // clay_shutdown();
  //   SDL_DestroyRenderer(renderer);
  //   SDL_DestroyWindow(window);
  //   SDL_Quit();

}

declare "C" init();

main(): i32 {
  assertTypes();
  // fib(10);
  // init(); 
  const a = Result<i32, u8> {
    .success: false,
    .isSuccess: false,
  };
  // test2(); 
  return 0;
  // return window();
}
